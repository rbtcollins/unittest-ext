diff -u -x '*.pyc' --recursive --new-file cpython/Lib/unittest/case.py unittest2/case.py
--- cpython/Lib/unittest/case.py	2011-03-24 02:43:51.000000000 -0400
+++ unittest2/case.py	2011-03-25 21:38:23.000000000 -0400
@@ -7,6 +7,9 @@
 import re
 import warnings
 import collections
+import unittest
+
+from .compatibility import Counter
 
 from . import result
 from .util import (strclass, safe_repr, sorted_list_difference,
@@ -223,7 +226,7 @@
         return default
 
 
-class TestCase(object):
+class TestCase(unittest.TestCase):
     """A class whose instances are single test cases.
 
     By default, the test code itself should be placed in a method named
@@ -953,8 +956,8 @@
         """
         first_seq, second_seq = list(first), list(second)
         try:
-            first = collections.Counter(first_seq)
-            second = collections.Counter(second_seq)
+            first = Counter(first_seq)
+            second = Counter(second_seq)
         except TypeError:
             # Handle case with unhashable elements
             differences = _count_diff_all_purpose(first_seq, second_seq)
@@ -971,6 +974,9 @@
             msg = self._formatMessage(msg, standardMsg)
             self.fail(msg)
 
+    # Alias for backwards compatibility
+    assertItemsEqual = assertCountEqual
+
     def assertMultiLineEqual(self, first, second, msg=None):
         """Assert that two multi-line strings are equal."""
         self.assertIsInstance(first, str, 'First argument is not a string')
diff -u -x '*.pyc' --recursive --new-file cpython/Lib/unittest/compatibility.py unittest2/compatibility.py
--- cpython/Lib/unittest/compatibility.py	1969-12-31 19:00:00.000000000 -0500
+++ unittest2/compatibility.py	2011-03-25 21:38:23.000000000 -0400
@@ -0,0 +1,321 @@
+try:
+    from functools import cmp_to_key
+except ImportError:
+    # Python 3.0 / 3.1
+    def cmp_to_key(mycmp):
+        """Convert a cmp= function into a key= function"""
+        class K(object):
+            def __init__(self, obj, *args):
+                self.obj = obj
+            def __lt__(self, other):
+                return mycmp(self.obj, other.obj) < 0
+            def __gt__(self, other):
+                return mycmp(self.obj, other.obj) > 0
+            def __eq__(self, other):
+                return mycmp(self.obj, other.obj) == 0
+            def __le__(self, other):
+                return mycmp(self.obj, other.obj) <= 0
+            def __ge__(self, other):
+                return mycmp(self.obj, other.obj) >= 0
+            def __ne__(self, other):
+                return mycmp(self.obj, other.obj) != 0
+            def __hash__(self):
+                raise TypeError('hash not implemented')
+        return K
+
+try:
+    from collections import OrderedDict, Counter
+except ImportError:
+    # Python 3.0
+
+    # OrderedDict taken from http://pypi.python.org/pypi/ordereddict/
+    class OrderedDict(dict):
+
+        def __init__(self, *args, **kwds):
+            if len(args) > 1:
+                raise TypeError('expected at most 1 arguments, got %d' % len(args))
+            try:
+                self.__end
+            except AttributeError:
+                self.clear()
+            self.update(*args, **kwds)
+
+        def clear(self):
+            self.__end = end = []
+            end += [None, end, end]         # sentinel node for doubly linked list
+            self.__map = {}                 # key --> [key, prev, next]
+            dict.clear(self)
+
+        def __setitem__(self, key, value):
+            if key not in self:
+                end = self.__end
+                curr = end[1]
+                curr[2] = end[1] = self.__map[key] = [key, curr, end]
+            dict.__setitem__(self, key, value)
+
+        def __delitem__(self, key):
+            dict.__delitem__(self, key)
+            key, prev, next = self.__map.pop(key)
+            prev[2] = next
+            next[1] = prev
+
+        def __iter__(self):
+            end = self.__end
+            curr = end[2]
+            while curr is not end:
+                yield curr[0]
+                curr = curr[2]
+
+        def __reversed__(self):
+            end = self.__end
+            curr = end[1]
+            while curr is not end:
+                yield curr[0]
+                curr = curr[1]
+
+        def popitem(self, last=True):
+            if not self:
+                raise KeyError('dictionary is empty')
+            if last:
+                key = reversed(self).next()
+            else:
+                key = iter(self).next()
+            value = self.pop(key)
+            return key, value
+
+        def __reduce__(self):
+            items = [[k, self[k]] for k in self]
+            tmp = self.__map, self.__end
+            del self.__map, self.__end
+            inst_dict = vars(self).copy()
+            self.__map, self.__end = tmp
+            if inst_dict:
+                return (self.__class__, (items,), inst_dict)
+            return self.__class__, (items,)
+
+        def keys(self):
+            return list(self)
+
+#         setdefault = DictMixin.setdefault
+#         update = DictMixin.update
+#         pop = DictMixin.pop
+#         values = DictMixin.values
+#         items = DictMixin.items
+#         iterkeys = DictMixin.iterkeys
+#         itervalues = DictMixin.itervalues
+#         iteritems = DictMixin.iteritems
+
+        def __repr__(self):
+            if not self:
+                return '%s()' % (self.__class__.__name__,)
+            return '%s(%r)' % (self.__class__.__name__, self.items())
+
+        def copy(self):
+            return self.__class__(self)
+
+        @classmethod
+        def fromkeys(cls, iterable, value=None):
+            d = cls()
+            for key in iterable:
+                d[key] = value
+            return d
+
+        def __eq__(self, other):
+            if isinstance(other, OrderedDict):
+                if len(self) != len(other):
+                    return False
+                for p, q in  zip(self.items(), other.items()):
+                    if p != q:
+                        return False
+                return True
+            return dict.__eq__(self, other)
+
+        def __ne__(self, other):
+            return not self == other
+
+
+    # Taken from Python 3.1
+    class Counter(dict):
+
+        def __init__(self, iterable=None, **kwds):
+            self.update(iterable, **kwds)
+
+        def __missing__(self, key):
+            'The count of elements not in the Counter is zero.'
+            # Needed so that self[missing_item] does not raise KeyError
+            return 0
+
+        def most_common(self, n=None):
+            '''List the n most common elements and their counts from the most
+            common to the least.  If n is None, then list all element counts.
+
+            >>> Counter('abracadabra').most_common(3)
+            [('a', 5), ('r', 2), ('b', 2)]
+
+            '''
+            # Emulate Bag.sortedByCount from Smalltalk
+            if n is None:
+                return sorted(self.items(), key=_itemgetter(1), reverse=True)
+            return _heapq.nlargest(n, self.items(), key=_itemgetter(1))
+
+        def elements(self):
+            '''Iterator over elements repeating each as many times as its count.
+
+            >>> c = Counter('ABCABC')
+            >>> sorted(c.elements())
+            ['A', 'A', 'B', 'B', 'C', 'C']
+
+            # Knuth's example for prime factors of 1836:  2**2 * 3**3 * 17**1
+            >>> prime_factors = Counter({2: 2, 3: 3, 17: 1})
+            >>> product = 1
+            >>> for factor in prime_factors.elements():     # loop over factors
+            ...     product *= factor                       # and multiply them
+            >>> product
+            1836
+
+            Note, if an element's count has been set to zero or is a negative
+            number, elements() will ignore it.
+
+            '''
+            # Emulate Bag.do from Smalltalk and Multiset.begin from C++.
+            return _chain.from_iterable(_starmap(_repeat, self.items()))
+
+        # Override dict methods where necessary
+
+        @classmethod
+        def fromkeys(cls, iterable, v=None):
+            # There is no equivalent method for counters because setting v=1
+            # means that no element can have a count greater than one.
+            raise NotImplementedError(
+                'Counter.fromkeys() is undefined.  Use Counter(iterable) instead.')
+
+        def update(self, iterable=None, **kwds):
+            '''Like dict.update() but add counts instead of replacing them.
+
+            Source can be an iterable, a dictionary, or another Counter instance.
+
+            >>> c = Counter('which')
+            >>> c.update('witch')           # add elements from another iterable
+            >>> d = Counter('watch')
+            >>> c.update(d)                 # add elements from another counter
+            >>> c['h']                      # four 'h' in which, witch, and watch
+            4
+
+            '''
+            # The regular dict.update() operation makes no sense here because the
+            # replace behavior results in the some of original untouched counts
+            # being mixed-in with all of the other counts for a mismash that
+            # doesn't have a straight-forward interpretation in most counting
+            # contexts.  Instead, we implement straight-addition.  Both the inputs
+            # and outputs are allowed to contain zero and negative counts.
+
+            if iterable is not None:
+
+                # No 'Mapping' in Python 3.0 so using straight
+                # dict for type checking.  This is satisfactory
+                # for our limited use case
+                if isinstance(iterable, dict):
+                    if self:
+                        self_get = self.get
+                        for elem, count in iterable.items():
+                            self[elem] = count + self_get(elem, 0)
+                    else:
+                        dict.update(self, iterable) # fast path when counter is empty
+                else:
+                    self_get = self.get
+                    for elem in iterable:
+                        self[elem] = 1 + self_get(elem, 0)
+            if kwds:
+                self.update(kwds)
+
+        def copy(self):
+            'Like dict.copy() but returns a Counter instance instead of a dict.'
+            return Counter(self)
+
+        def __delitem__(self, elem):
+            'Like dict.__delitem__() but does not raise KeyError for missing values.'
+            if elem in self:
+                dict.__delitem__(self, elem)
+
+        def __repr__(self):
+            if not self:
+                return '%s()' % self.__class__.__name__
+            items = ', '.join(map('%r: %r'.__mod__, self.most_common()))
+            return '%s({%s})' % (self.__class__.__name__, items)
+
+        # Multiset-style mathematical operations discussed in:
+        #       Knuth TAOCP Volume II section 4.6.3 exercise 19
+        #       and at http://en.wikipedia.org/wiki/Multiset
+        #
+        # Outputs guaranteed to only include positive counts.
+        #
+        # To strip negative and zero counts, add-in an empty counter:
+        #       c += Counter()
+
+        def __add__(self, other):
+            '''Add counts from two counters.
+
+            >>> Counter('abbb') + Counter('bcc')
+            Counter({'b': 4, 'c': 2, 'a': 1})
+
+            '''
+            if not isinstance(other, Counter):
+                return NotImplemented
+            result = Counter()
+            for elem in set(self) | set(other):
+                newcount = self[elem] + other[elem]
+                if newcount > 0:
+                    result[elem] = newcount
+            return result
+
+        def __sub__(self, other):
+            ''' Subtract count, but keep only results with positive counts.
+
+            >>> Counter('abbbc') - Counter('bccd')
+            Counter({'b': 2, 'a': 1})
+
+            '''
+            if not isinstance(other, Counter):
+                return NotImplemented
+            result = Counter()
+            for elem in set(self) | set(other):
+                newcount = self[elem] - other[elem]
+                if newcount > 0:
+                    result[elem] = newcount
+            return result
+
+        def __or__(self, other):
+            '''Union is the maximum of value in either of the input counters.
+
+            >>> Counter('abbb') | Counter('bcc')
+            Counter({'b': 3, 'c': 2, 'a': 1})
+
+            '''
+            if not isinstance(other, Counter):
+                return NotImplemented
+            result = Counter()
+            for elem in set(self) | set(other):
+                p, q = self[elem], other[elem]
+                newcount = q if p < q else p
+                if newcount > 0:
+                    result[elem] = newcount
+            return result
+
+        def __and__(self, other):
+            ''' Intersection is the minimum of corresponding counts.
+
+            >>> Counter('abbb') & Counter('bcc')
+            Counter({'b': 1})
+
+            '''
+            if not isinstance(other, Counter):
+                return NotImplemented
+            result = Counter()
+            if len(self) < len(other):
+                self, other = other, self
+            for elem in filter(self.__contains__, other):
+                p, q = self[elem], other[elem]
+                newcount = p if p < q else q
+                if newcount > 0:
+                    result[elem] = newcount
+            return result
diff -u -x '*.pyc' --recursive --new-file cpython/Lib/unittest/__init__.py unittest2/__init__.py
--- cpython/Lib/unittest/__init__.py	2011-03-24 02:43:51.000000000 -0400
+++ unittest2/__init__.py	2011-03-25 21:38:23.000000000 -0400
@@ -9,9 +9,9 @@
 
 Simple usage:
 
-    import unittest
+    import unittest2
 
-    class IntegerArithmenticTestCase(unittest.TestCase):
+    class IntegerArithmenticTestCase(unittest2.TestCase):
         def testAdd(self):  ## test method names begin 'test*'
             self.assertEqual((1 + 2), 3)
             self.assertEqual(0 + 1, 1)
@@ -20,7 +20,7 @@
             self.assertEqual((5 * 8), 40)
 
     if __name__ == '__main__':
-        unittest.main()
+        unittest2.main()
 
 Further information is available in the bundled documentation, and from
 
@@ -53,6 +53,8 @@
 # Expose obsolete functions for backwards compatibility
 __all__.extend(['getTestCaseNames', 'makeSuite', 'findTestCases'])
 
+__version__ = '0.5.1'
+
 __unittest = True
 
 from .result import TestResult
diff -u -x '*.pyc' --recursive --new-file cpython/Lib/unittest/loader.py unittest2/loader.py
--- cpython/Lib/unittest/loader.py	2011-03-24 02:43:51.000000000 -0400
+++ unittest2/loader.py	2011-03-25 21:38:23.000000000 -0400
@@ -5,11 +5,12 @@
 import sys
 import traceback
 import types
-import functools
+import unittest
 
 from fnmatch import fnmatch
 
 from . import case, suite, util
+from .compatibility import cmp_to_key
 
 __unittest = True
 
@@ -35,7 +36,7 @@
     return suiteClass((TestClass(methodname),))
 
 
-class TestLoader(object):
+class TestLoader(unittest.TestLoader):
     """
     This class is responsible for loading tests according to various criteria
     and returning them wrapped in a TestSuite
@@ -142,7 +143,7 @@
         testFnNames = testFnNames = list(filter(isTestMethod,
                                                 dir(testCaseClass)))
         if self.sortTestMethodsUsing:
-            testFnNames.sort(key=functools.cmp_to_key(self.sortTestMethodsUsing))
+            testFnNames.sort(key=cmp_to_key(self.sortTestMethodsUsing))
         return testFnNames
 
     def discover(self, start_dir, pattern='test*.py', top_level_dir=None):
diff -u -x '*.pyc' --recursive --new-file cpython/Lib/unittest/main.py unittest2/main.py
--- cpython/Lib/unittest/main.py	2011-03-24 02:43:51.000000000 -0400
+++ unittest2/main.py	2011-03-25 21:38:23.000000000 -0400
@@ -3,6 +3,7 @@
 import sys
 import os
 import types
+import unittest
 
 from . import loader, runner
 from .signals import installHandler
@@ -77,7 +78,7 @@
 def _convert_names(names):
     return [_convert_name(name) for name in names]
 
-class TestProgram(object):
+class TestProgram(unittest.TestProgram):
     """A command-line program that runs a set of tests; this is primarily
        for making test modules conveniently executable.
     """
diff -u -x '*.pyc' --recursive --new-file cpython/Lib/unittest/result.py unittest2/result.py
--- cpython/Lib/unittest/result.py	2011-03-24 02:43:51.000000000 -0400
+++ unittest2/result.py	2011-03-25 21:38:23.000000000 -0400
@@ -4,6 +4,7 @@
 import io
 import sys
 import traceback
+import unittest
 
 from . import util
 from functools import wraps
@@ -22,7 +23,7 @@
 STDERR_LINE = '\nStderr:\n%s'
 
 
-class TestResult(object):
+class TestResult(unittest.TestResult):
     """Holder for test result information.
 
     Test results are automatically managed by the TestCase and TestSuite
diff -u -x '*.pyc' --recursive --new-file cpython/Lib/unittest/suite.py unittest2/suite.py
--- cpython/Lib/unittest/suite.py	2011-03-24 02:43:51.000000000 -0400
+++ unittest2/suite.py	2011-03-25 21:38:23.000000000 -0400
@@ -1,6 +1,7 @@
 """TestSuite"""
 
 import sys
+import unittest
 
 from . import case
 from . import util
@@ -13,7 +14,7 @@
     func()
 
 
-class BaseTestSuite(object):
+class BaseTestSuite(unittest.TestSuite):
     """A simple test suite that doesn't provide class or module shared fixtures.
     """
     def __init__(self, tests=()):
@@ -43,7 +44,7 @@
     def addTest(self, test):
         # sanity checks
         if not hasattr(test, '__call__'):
-            raise TypeError("{} is not callable".format(repr(test)))
+            raise TypeError("{0} is not callable".format(repr(test)))
         if isinstance(test, type) and issubclass(test,
                                                  (case.TestCase, TestSuite)):
             raise TypeError("TestCases and TestSuites must be instantiated "
diff -u -x '*.pyc' --recursive --new-file cpython/Lib/unittest/test/support.py unittest2/test/support.py
--- cpython/Lib/unittest/test/support.py	2011-03-24 02:43:51.000000000 -0400
+++ unittest2/test/support.py	2011-03-25 21:38:23.000000000 -0400
@@ -1,4 +1,9 @@
-import unittest
+import unittest2 as unittest
+
+import contextlib
+import re
+import sys
+import warnings
 
 
 class TestEquality(object):
@@ -116,3 +121,86 @@
 
     def wasSuccessful(self):
         return True
+
+class WarningsRecorder(object):
+    """Convenience wrapper for the warnings list returned on
+       entry to the warnings.catch_warnings() context manager.
+    """
+    def __init__(self, warnings_list):
+        self._warnings = warnings_list
+        self._last = 0
+
+    def __getattr__(self, attr):
+        if len(self._warnings) > self._last:
+            return getattr(self._warnings[-1], attr)
+        elif attr in warnings.WarningMessage._WARNING_DETAILS:
+            return None
+        raise AttributeError("%r has no attribute %r" % (self, attr))
+
+    @property
+    def warnings(self):
+        return self._warnings[self._last:]
+
+    def reset(self):
+        self._last = len(self._warnings)
+
+def _filterwarnings(filters, quiet=False):
+    """Catch the warnings, then check if all the expected
+    warnings have been raised and re-raise unexpected warnings.
+    If 'quiet' is True, only re-raise the unexpected warnings.
+    """
+    # Clear the warning registry of the calling module
+    # in order to re-raise the warnings.
+    frame = sys._getframe(2)
+    registry = frame.f_globals.get('__warningregistry__')
+    if registry:
+        registry.clear()
+    with warnings.catch_warnings(record=True) as w:
+        # Set filter "always" to record all warnings.  Because
+        # test_warnings swap the module, we need to look up in
+        # the sys.modules dictionary.
+        sys.modules['warnings'].simplefilter("always")
+        yield WarningsRecorder(w)
+    # Filter the recorded warnings
+    reraise = [warning.message for warning in w]
+    missing = []
+    for msg, cat in filters:
+        seen = False
+        for exc in reraise[:]:
+            message = str(exc)
+            # Filter out the matching messages
+            if (re.match(msg, message, re.I) and
+                issubclass(exc.__class__, cat)):
+                seen = True
+                reraise.remove(exc)
+        if not seen and not quiet:
+            # This filter caught nothing
+            missing.append((msg, cat.__name__))
+    if reraise:
+        raise AssertionError("unhandled warning %r" % reraise[0])
+    if missing:
+        raise AssertionError("filter (%r, %s) did not catch any warning" %
+                             missing[0])
+
+@contextlib.contextmanager
+def check_warnings(*filters, **kwargs):
+    """Context manager to silence warnings.
+
+    Accept 2-tuples as positional arguments:
+        ("message regexp", WarningCategory)
+
+    Optional argument:
+     - if 'quiet' is True, it does not fail if a filter catches nothing
+        (default True without argument,
+         default False if some filters are defined)
+
+    Without argument, it defaults to:
+        check_warnings(("", Warning), quiet=True)
+    """
+    quiet = kwargs.get('quiet')
+    if not filters:
+        filters = (("", Warning),)
+        # Preserve backward compatibility
+        if quiet is None:
+            quiet = True
+    return _filterwarnings(filters, quiet)
diff -u -x '*.pyc' --recursive --new-file cpython/Lib/unittest/test/test_assertions.py unittest2/test/test_assertions.py
--- cpython/Lib/unittest/test/test_assertions.py	2011-03-24 02:43:51.000000000 -0400
+++ unittest2/test/test_assertions.py	2011-03-25 21:38:23.000000000 -0400
@@ -1,6 +1,6 @@
 import datetime
 import warnings
-import unittest
+import unittest2 as unittest
 
 
 class Test_Assertions(unittest.TestCase):
diff -u -x '*.pyc' --recursive --new-file cpython/Lib/unittest/test/test_break.py unittest2/test/test_break.py
--- cpython/Lib/unittest/test/test_break.py	2011-03-24 02:43:51.000000000 -0400
+++ unittest2/test/test_break.py	2011-03-25 21:38:23.000000000 -0400
@@ -5,7 +5,7 @@
 import signal
 import weakref
 
-import unittest
+import unittest2 as unittest
 
 
 @unittest.skipUnless(hasattr(os, 'kill'), "Test requires os.kill")
diff -u -x '*.pyc' --recursive --new-file cpython/Lib/unittest/test/test_case.py unittest2/test/test_case.py
--- cpython/Lib/unittest/test/test_case.py	2011-03-24 02:43:51.000000000 -0400
+++ unittest2/test/test_case.py	2011-03-25 21:38:23.000000000 -0400
@@ -9,7 +9,7 @@
 from copy import deepcopy
 from test import support
 
-import unittest
+import unittest2 as unittest
 
 from .support import (
     TestEquality, TestHashing, LoggingResult,
@@ -752,6 +752,10 @@
         expected = {(3,1,'a'), (1,3,'b'), (1,0,'d'), (0,1,'e')}
         self.assertEqual(diffs, expected)
 
+    def testCountEqualAlias(self):
+        self.assertTrue(hasattr(unittest.TestCase, 'assertItemsEqual'))
+        self.assertTrue(unittest.TestCase.assertItemsEqual is unittest.TestCase.assertCountEqual)
+
     def testAssertSetEqual(self):
         set1 = set()
         set2 = set()
@@ -1217,3 +1221,7 @@
             klass('test_something').run(result)
             self.assertEqual(len(result.errors), 1)
             self.assertEqual(result.testsRun, 1)
+
+    def testBaseClassInheritance(self):
+        import unittest as unittestorig
+        self.assertTrue(issubclass(unittest.TestCase, unittestorig.TestCase))
diff -u -x '*.pyc' --recursive --new-file cpython/Lib/unittest/test/test_discovery.py unittest2/test/test_discovery.py
--- cpython/Lib/unittest/test/test_discovery.py	2011-03-24 02:43:51.000000000 -0400
+++ unittest2/test/test_discovery.py	2011-03-25 21:38:23.000000000 -0400
@@ -2,7 +2,7 @@
 import re
 import sys
 
-import unittest
+import unittest2 as unittest
 
 
 class TestableTestProgram(unittest.TestProgram):
@@ -386,7 +386,7 @@
             self.assertEqual(start_dir, expectedPath)
             return tests
         loader._find_tests = _find_tests
-        suite = loader.discover('unittest.test')
+        suite = loader.discover('unittest2.test')
         self.assertTrue(self.wasRun)
         self.assertEqual(suite._tests, tests)
 
diff -u -x '*.pyc' --recursive --new-file cpython/Lib/unittest/test/test_functiontestcase.py unittest2/test/test_functiontestcase.py
--- cpython/Lib/unittest/test/test_functiontestcase.py	2011-03-24 02:43:51.000000000 -0400
+++ unittest2/test/test_functiontestcase.py	2011-03-25 21:38:23.000000000 -0400
@@ -1,4 +1,4 @@
-import unittest
+import unittest2 as unittest
 
 from .support import LoggingResult
 
diff -u -x '*.pyc' --recursive --new-file cpython/Lib/unittest/test/test_loader.py unittest2/test/test_loader.py
--- cpython/Lib/unittest/test/test_loader.py	2011-03-24 02:43:51.000000000 -0400
+++ unittest2/test/test_loader.py	2011-03-25 21:38:23.000000000 -0400
@@ -2,7 +2,7 @@
 import types
 
 
-import unittest
+import unittest2 as unittest
 
 
 class Test_TestLoader(unittest.TestCase):
@@ -239,7 +239,7 @@
         try:
             loader.loadTestsFromName('sdasfasfasdf')
         except ImportError as e:
-            self.assertEqual(str(e), "No module named 'sdasfasfasdf'")
+            self.assertEqual(str(e), "No module named sdasfasfasdf")
         else:
             self.fail("TestLoader.loadTestsFromName failed to raise ImportError")
 
@@ -524,7 +524,7 @@
         # We're going to try to load this module as a side-effect, so it
         # better not be loaded before we try.
         #
-        module_name = 'unittest.test.dummy'
+        module_name = 'unittest2.test.dummy'
         sys.modules.pop(module_name, None)
 
         loader = unittest.TestLoader()
@@ -619,7 +619,7 @@
         try:
             loader.loadTestsFromNames(['sdasfasfasdf'])
         except ImportError as e:
-            self.assertEqual(str(e), "No module named 'sdasfasfasdf'")
+            self.assertEqual(str(e), "No module named sdasfasfasdf")
         else:
             self.fail("TestLoader.loadTestsFromNames failed to raise ImportError")
 
@@ -907,7 +907,7 @@
         # We're going to try to load this module as a side-effect, so it
         # better not be loaded before we try.
         #
-        module_name = 'unittest.test.dummy'
+        module_name = 'unittest2.test.dummy'
         sys.modules.pop(module_name, None)
 
         loader = unittest.TestLoader()
@@ -1290,3 +1290,7 @@
     def test_suiteClass__default_value(self):
         loader = unittest.TestLoader()
         self.assertTrue(loader.suiteClass is unittest.TestSuite)
+
+    def testBaseClassInheritance(self):
+        import unittest as unittestorig
+        self.assertTrue(issubclass(unittest.TestLoader, unittestorig.TestLoader))
diff -u -x '*.pyc' --recursive --new-file cpython/Lib/unittest/test/test_loader.py~ unittest2/test/test_loader.py~
--- cpython/Lib/unittest/test/test_loader.py~	1969-12-31 19:00:00.000000000 -0500
+++ unittest2/test/test_loader.py~	2011-03-25 21:38:23.000000000 -0400
@@ -0,0 +1,1296 @@
+import sys
+import types
+
+
+import unittest2 as unittest
+
+
+class Test_TestLoader(unittest.TestCase):
+
+    ### Tests for TestLoader.loadTestsFromTestCase
+    ################################################################
+
+    # "Return a suite of all tests cases contained in the TestCase-derived
+    # class testCaseClass"
+    def test_loadTestsFromTestCase(self):
+        class Foo(unittest.TestCase):
+            def test_1(self): pass
+            def test_2(self): pass
+            def foo_bar(self): pass
+
+        tests = unittest.TestSuite([Foo('test_1'), Foo('test_2')])
+
+        loader = unittest.TestLoader()
+        self.assertEqual(loader.loadTestsFromTestCase(Foo), tests)
+
+    # "Return a suite of all tests cases contained in the TestCase-derived
+    # class testCaseClass"
+    #
+    # Make sure it does the right thing even if no tests were found
+    def test_loadTestsFromTestCase__no_matches(self):
+        class Foo(unittest.TestCase):
+            def foo_bar(self): pass
+
+        empty_suite = unittest.TestSuite()
+
+        loader = unittest.TestLoader()
+        self.assertEqual(loader.loadTestsFromTestCase(Foo), empty_suite)
+
+    # "Return a suite of all tests cases contained in the TestCase-derived
+    # class testCaseClass"
+    #
+    # What happens if loadTestsFromTestCase() is given an object
+    # that isn't a subclass of TestCase? Specifically, what happens
+    # if testCaseClass is a subclass of TestSuite?
+    #
+    # This is checked for specifically in the code, so we better add a
+    # test for it.
+    def test_loadTestsFromTestCase__TestSuite_subclass(self):
+        class NotATestCase(unittest.TestSuite):
+            pass
+
+        loader = unittest.TestLoader()
+        try:
+            loader.loadTestsFromTestCase(NotATestCase)
+        except TypeError:
+            pass
+        else:
+            self.fail('Should raise TypeError')
+
+    # "Return a suite of all tests cases contained in the TestCase-derived
+    # class testCaseClass"
+    #
+    # Make sure loadTestsFromTestCase() picks up the default test method
+    # name (as specified by TestCase), even though the method name does
+    # not match the default TestLoader.testMethodPrefix string
+    def test_loadTestsFromTestCase__default_method_name(self):
+        class Foo(unittest.TestCase):
+            def runTest(self):
+                pass
+
+        loader = unittest.TestLoader()
+        # This has to be false for the test to succeed
+        self.assertFalse('runTest'.startswith(loader.testMethodPrefix))
+
+        suite = loader.loadTestsFromTestCase(Foo)
+        self.assertIsInstance(suite, loader.suiteClass)
+        self.assertEqual(list(suite), [Foo('runTest')])
+
+    ################################################################
+    ### /Tests for TestLoader.loadTestsFromTestCase
+
+    ### Tests for TestLoader.loadTestsFromModule
+    ################################################################
+
+    # "This method searches `module` for classes derived from TestCase"
+    def test_loadTestsFromModule__TestCase_subclass(self):
+        m = types.ModuleType('m')
+        class MyTestCase(unittest.TestCase):
+            def test(self):
+                pass
+        m.testcase_1 = MyTestCase
+
+        loader = unittest.TestLoader()
+        suite = loader.loadTestsFromModule(m)
+        self.assertIsInstance(suite, loader.suiteClass)
+
+        expected = [loader.suiteClass([MyTestCase('test')])]
+        self.assertEqual(list(suite), expected)
+
+    # "This method searches `module` for classes derived from TestCase"
+    #
+    # What happens if no tests are found (no TestCase instances)?
+    def test_loadTestsFromModule__no_TestCase_instances(self):
+        m = types.ModuleType('m')
+
+        loader = unittest.TestLoader()
+        suite = loader.loadTestsFromModule(m)
+        self.assertIsInstance(suite, loader.suiteClass)
+        self.assertEqual(list(suite), [])
+
+    # "This method searches `module` for classes derived from TestCase"
+    #
+    # What happens if no tests are found (TestCases instances, but no tests)?
+    def test_loadTestsFromModule__no_TestCase_tests(self):
+        m = types.ModuleType('m')
+        class MyTestCase(unittest.TestCase):
+            pass
+        m.testcase_1 = MyTestCase
+
+        loader = unittest.TestLoader()
+        suite = loader.loadTestsFromModule(m)
+        self.assertIsInstance(suite, loader.suiteClass)
+
+        self.assertEqual(list(suite), [loader.suiteClass()])
+
+    # "This method searches `module` for classes derived from TestCase"s
+    #
+    # What happens if loadTestsFromModule() is given something other
+    # than a module?
+    #
+    # XXX Currently, it succeeds anyway. This flexibility
+    # should either be documented or loadTestsFromModule() should
+    # raise a TypeError
+    #
+    # XXX Certain people are using this behaviour. We'll add a test for it
+    def test_loadTestsFromModule__not_a_module(self):
+        class MyTestCase(unittest.TestCase):
+            def test(self):
+                pass
+
+        class NotAModule(object):
+            test_2 = MyTestCase
+
+        loader = unittest.TestLoader()
+        suite = loader.loadTestsFromModule(NotAModule)
+
+        reference = [unittest.TestSuite([MyTestCase('test')])]
+        self.assertEqual(list(suite), reference)
+
+
+    # Check that loadTestsFromModule honors (or not) a module
+    # with a load_tests function.
+    def test_loadTestsFromModule__load_tests(self):
+        m = types.ModuleType('m')
+        class MyTestCase(unittest.TestCase):
+            def test(self):
+                pass
+        m.testcase_1 = MyTestCase
+
+        load_tests_args = []
+        def load_tests(loader, tests, pattern):
+            self.assertIsInstance(tests, unittest.TestSuite)
+            load_tests_args.extend((loader, tests, pattern))
+            return tests
+        m.load_tests = load_tests
+
+        loader = unittest.TestLoader()
+        suite = loader.loadTestsFromModule(m)
+        self.assertIsInstance(suite, unittest.TestSuite)
+        self.assertEqual(load_tests_args, [loader, suite, None])
+
+        load_tests_args = []
+        suite = loader.loadTestsFromModule(m, use_load_tests=False)
+        self.assertEqual(load_tests_args, [])
+
+    def test_loadTestsFromModule__faulty_load_tests(self):
+        m = types.ModuleType('m')
+
+        def load_tests(loader, tests, pattern):
+            raise TypeError('some failure')
+        m.load_tests = load_tests
+
+        loader = unittest.TestLoader()
+        suite = loader.loadTestsFromModule(m)
+        self.assertIsInstance(suite, unittest.TestSuite)
+        self.assertEqual(suite.countTestCases(), 1)
+        test = list(suite)[0]
+
+        self.assertRaisesRegex(TypeError, "some failure", test.m)
+
+    ################################################################
+    ### /Tests for TestLoader.loadTestsFromModule()
+
+    ### Tests for TestLoader.loadTestsFromName()
+    ################################################################
+
+    # "The specifier name is a ``dotted name'' that may resolve either to
+    # a module, a test case class, a TestSuite instance, a test method
+    # within a test case class, or a callable object which returns a
+    # TestCase or TestSuite instance."
+    #
+    # Is ValueError raised in response to an empty name?
+    def test_loadTestsFromName__empty_name(self):
+        loader = unittest.TestLoader()
+
+        try:
+            loader.loadTestsFromName('')
+        except ValueError as e:
+            self.assertEqual(str(e), "Empty module name")
+        else:
+            self.fail("TestLoader.loadTestsFromName failed to raise ValueError")
+
+    # "The specifier name is a ``dotted name'' that may resolve either to
+    # a module, a test case class, a TestSuite instance, a test method
+    # within a test case class, or a callable object which returns a
+    # TestCase or TestSuite instance."
+    #
+    # What happens when the name contains invalid characters?
+    def test_loadTestsFromName__malformed_name(self):
+        loader = unittest.TestLoader()
+
+        # XXX Should this raise ValueError or ImportError?
+        try:
+            loader.loadTestsFromName('abc () //')
+        except ValueError:
+            pass
+        except ImportError:
+            pass
+        else:
+            self.fail("TestLoader.loadTestsFromName failed to raise ValueError")
+
+    # "The specifier name is a ``dotted name'' that may resolve ... to a
+    # module"
+    #
+    # What happens when a module by that name can't be found?
+    def test_loadTestsFromName__unknown_module_name(self):
+        loader = unittest.TestLoader()
+
+        try:
+            loader.loadTestsFromName('sdasfasfasdf')
+        except ImportError as e:
+            self.assertEqual(str(e), "No module named 'sdasfasfasdf'")
+        else:
+            self.fail("TestLoader.loadTestsFromName failed to raise ImportError")
+
+    # "The specifier name is a ``dotted name'' that may resolve either to
+    # a module, a test case class, a TestSuite instance, a test method
+    # within a test case class, or a callable object which returns a
+    # TestCase or TestSuite instance."
+    #
+    # What happens when the module is found, but the attribute can't?
+    def test_loadTestsFromName__unknown_attr_name(self):
+        loader = unittest.TestLoader()
+
+        try:
+            loader.loadTestsFromName('unittest.sdasfasfasdf')
+        except AttributeError as e:
+            self.assertEqual(str(e), "'module' object has no attribute 'sdasfasfasdf'")
+        else:
+            self.fail("TestLoader.loadTestsFromName failed to raise AttributeError")
+
+    # "The specifier name is a ``dotted name'' that may resolve either to
+    # a module, a test case class, a TestSuite instance, a test method
+    # within a test case class, or a callable object which returns a
+    # TestCase or TestSuite instance."
+    #
+    # What happens when we provide the module, but the attribute can't be
+    # found?
+    def test_loadTestsFromName__relative_unknown_name(self):
+        loader = unittest.TestLoader()
+
+        try:
+            loader.loadTestsFromName('sdasfasfasdf', unittest)
+        except AttributeError as e:
+            self.assertEqual(str(e), "'module' object has no attribute 'sdasfasfasdf'")
+        else:
+            self.fail("TestLoader.loadTestsFromName failed to raise AttributeError")
+
+    # "The specifier name is a ``dotted name'' that may resolve either to
+    # a module, a test case class, a TestSuite instance, a test method
+    # within a test case class, or a callable object which returns a
+    # TestCase or TestSuite instance."
+    # ...
+    # "The method optionally resolves name relative to the given module"
+    #
+    # Does loadTestsFromName raise ValueError when passed an empty
+    # name relative to a provided module?
+    #
+    # XXX Should probably raise a ValueError instead of an AttributeError
+    def test_loadTestsFromName__relative_empty_name(self):
+        loader = unittest.TestLoader()
+
+        try:
+            loader.loadTestsFromName('', unittest)
+        except AttributeError as e:
+            pass
+        else:
+            self.fail("Failed to raise AttributeError")
+
+    # "The specifier name is a ``dotted name'' that may resolve either to
+    # a module, a test case class, a TestSuite instance, a test method
+    # within a test case class, or a callable object which returns a
+    # TestCase or TestSuite instance."
+    # ...
+    # "The method optionally resolves name relative to the given module"
+    #
+    # What happens when an impossible name is given, relative to the provided
+    # `module`?
+    def test_loadTestsFromName__relative_malformed_name(self):
+        loader = unittest.TestLoader()
+
+        # XXX Should this raise AttributeError or ValueError?
+        try:
+            loader.loadTestsFromName('abc () //', unittest)
+        except ValueError:
+            pass
+        except AttributeError:
+            pass
+        else:
+            self.fail("TestLoader.loadTestsFromName failed to raise ValueError")
+
+    # "The method optionally resolves name relative to the given module"
+    #
+    # Does loadTestsFromName raise TypeError when the `module` argument
+    # isn't a module object?
+    #
+    # XXX Accepts the not-a-module object, ignorning the object's type
+    # This should raise an exception or the method name should be changed
+    #
+    # XXX Some people are relying on this, so keep it for now
+    def test_loadTestsFromName__relative_not_a_module(self):
+        class MyTestCase(unittest.TestCase):
+            def test(self):
+                pass
+
+        class NotAModule(object):
+            test_2 = MyTestCase
+
+        loader = unittest.TestLoader()
+        suite = loader.loadTestsFromName('test_2', NotAModule)
+
+        reference = [MyTestCase('test')]
+        self.assertEqual(list(suite), reference)
+
+    # "The specifier name is a ``dotted name'' that may resolve either to
+    # a module, a test case class, a TestSuite instance, a test method
+    # within a test case class, or a callable object which returns a
+    # TestCase or TestSuite instance."
+    #
+    # Does it raise an exception if the name resolves to an invalid
+    # object?
+    def test_loadTestsFromName__relative_bad_object(self):
+        m = types.ModuleType('m')
+        m.testcase_1 = object()
+
+        loader = unittest.TestLoader()
+        try:
+            loader.loadTestsFromName('testcase_1', m)
+        except TypeError:
+            pass
+        else:
+            self.fail("Should have raised TypeError")
+
+    # "The specifier name is a ``dotted name'' that may
+    # resolve either to ... a test case class"
+    def test_loadTestsFromName__relative_TestCase_subclass(self):
+        m = types.ModuleType('m')
+        class MyTestCase(unittest.TestCase):
+            def test(self):
+                pass
+        m.testcase_1 = MyTestCase
+
+        loader = unittest.TestLoader()
+        suite = loader.loadTestsFromName('testcase_1', m)
+        self.assertIsInstance(suite, loader.suiteClass)
+        self.assertEqual(list(suite), [MyTestCase('test')])
+
+    # "The specifier name is a ``dotted name'' that may resolve either to
+    # a module, a test case class, a TestSuite instance, a test method
+    # within a test case class, or a callable object which returns a
+    # TestCase or TestSuite instance."
+    def test_loadTestsFromName__relative_TestSuite(self):
+        m = types.ModuleType('m')
+        class MyTestCase(unittest.TestCase):
+            def test(self):
+                pass
+        m.testsuite = unittest.TestSuite([MyTestCase('test')])
+
+        loader = unittest.TestLoader()
+        suite = loader.loadTestsFromName('testsuite', m)
+        self.assertIsInstance(suite, loader.suiteClass)
+
+        self.assertEqual(list(suite), [MyTestCase('test')])
+
+    # "The specifier name is a ``dotted name'' that may resolve ... to
+    # ... a test method within a test case class"
+    def test_loadTestsFromName__relative_testmethod(self):
+        m = types.ModuleType('m')
+        class MyTestCase(unittest.TestCase):
+            def test(self):
+                pass
+        m.testcase_1 = MyTestCase
+
+        loader = unittest.TestLoader()
+        suite = loader.loadTestsFromName('testcase_1.test', m)
+        self.assertIsInstance(suite, loader.suiteClass)
+
+        self.assertEqual(list(suite), [MyTestCase('test')])
+
+    # "The specifier name is a ``dotted name'' that may resolve either to
+    # a module, a test case class, a TestSuite instance, a test method
+    # within a test case class, or a callable object which returns a
+    # TestCase or TestSuite instance."
+    #
+    # Does loadTestsFromName() raise the proper exception when trying to
+    # resolve "a test method within a test case class" that doesn't exist
+    # for the given name (relative to a provided module)?
+    def test_loadTestsFromName__relative_invalid_testmethod(self):
+        m = types.ModuleType('m')
+        class MyTestCase(unittest.TestCase):
+            def test(self):
+                pass
+        m.testcase_1 = MyTestCase
+
+        loader = unittest.TestLoader()
+        try:
+            loader.loadTestsFromName('testcase_1.testfoo', m)
+        except AttributeError as e:
+            self.assertEqual(str(e), "type object 'MyTestCase' has no attribute 'testfoo'")
+        else:
+            self.fail("Failed to raise AttributeError")
+
+    # "The specifier name is a ``dotted name'' that may resolve ... to
+    # ... a callable object which returns a ... TestSuite instance"
+    def test_loadTestsFromName__callable__TestSuite(self):
+        m = types.ModuleType('m')
+        testcase_1 = unittest.FunctionTestCase(lambda: None)
+        testcase_2 = unittest.FunctionTestCase(lambda: None)
+        def return_TestSuite():
+            return unittest.TestSuite([testcase_1, testcase_2])
+        m.return_TestSuite = return_TestSuite
+
+        loader = unittest.TestLoader()
+        suite = loader.loadTestsFromName('return_TestSuite', m)
+        self.assertIsInstance(suite, loader.suiteClass)
+        self.assertEqual(list(suite), [testcase_1, testcase_2])
+
+    # "The specifier name is a ``dotted name'' that may resolve ... to
+    # ... a callable object which returns a TestCase ... instance"
+    def test_loadTestsFromName__callable__TestCase_instance(self):
+        m = types.ModuleType('m')
+        testcase_1 = unittest.FunctionTestCase(lambda: None)
+        def return_TestCase():
+            return testcase_1
+        m.return_TestCase = return_TestCase
+
+        loader = unittest.TestLoader()
+        suite = loader.loadTestsFromName('return_TestCase', m)
+        self.assertIsInstance(suite, loader.suiteClass)
+        self.assertEqual(list(suite), [testcase_1])
+
+    # "The specifier name is a ``dotted name'' that may resolve ... to
+    # ... a callable object which returns a TestCase ... instance"
+    #*****************************************************************
+    #Override the suiteClass attribute to ensure that the suiteClass
+    #attribute is used
+    def test_loadTestsFromName__callable__TestCase_instance_ProperSuiteClass(self):
+        class SubTestSuite(unittest.TestSuite):
+            pass
+        m = types.ModuleType('m')
+        testcase_1 = unittest.FunctionTestCase(lambda: None)
+        def return_TestCase():
+            return testcase_1
+        m.return_TestCase = return_TestCase
+
+        loader = unittest.TestLoader()
+        loader.suiteClass = SubTestSuite
+        suite = loader.loadTestsFromName('return_TestCase', m)
+        self.assertIsInstance(suite, loader.suiteClass)
+        self.assertEqual(list(suite), [testcase_1])
+
+    # "The specifier name is a ``dotted name'' that may resolve ... to
+    # ... a test method within a test case class"
+    #*****************************************************************
+    #Override the suiteClass attribute to ensure that the suiteClass
+    #attribute is used
+    def test_loadTestsFromName__relative_testmethod_ProperSuiteClass(self):
+        class SubTestSuite(unittest.TestSuite):
+            pass
+        m = types.ModuleType('m')
+        class MyTestCase(unittest.TestCase):
+            def test(self):
+                pass
+        m.testcase_1 = MyTestCase
+
+        loader = unittest.TestLoader()
+        loader.suiteClass=SubTestSuite
+        suite = loader.loadTestsFromName('testcase_1.test', m)
+        self.assertIsInstance(suite, loader.suiteClass)
+
+        self.assertEqual(list(suite), [MyTestCase('test')])
+
+    # "The specifier name is a ``dotted name'' that may resolve ... to
+    # ... a callable object which returns a TestCase or TestSuite instance"
+    #
+    # What happens if the callable returns something else?
+    def test_loadTestsFromName__callable__wrong_type(self):
+        m = types.ModuleType('m')
+        def return_wrong():
+            return 6
+        m.return_wrong = return_wrong
+
+        loader = unittest.TestLoader()
+        try:
+            suite = loader.loadTestsFromName('return_wrong', m)
+        except TypeError:
+            pass
+        else:
+            self.fail("TestLoader.loadTestsFromName failed to raise TypeError")
+
+    # "The specifier can refer to modules and packages which have not been
+    # imported; they will be imported as a side-effect"
+    def test_loadTestsFromName__module_not_loaded(self):
+        # We're going to try to load this module as a side-effect, so it
+        # better not be loaded before we try.
+        #
+        module_name = 'unittest2.test.dummy'
+        sys.modules.pop(module_name, None)
+
+        loader = unittest.TestLoader()
+        try:
+            suite = loader.loadTestsFromName(module_name)
+
+            self.assertIsInstance(suite, loader.suiteClass)
+            self.assertEqual(list(suite), [])
+
+            # module should now be loaded, thanks to loadTestsFromName()
+            self.assertIn(module_name, sys.modules)
+        finally:
+            if module_name in sys.modules:
+                del sys.modules[module_name]
+
+    ################################################################
+    ### Tests for TestLoader.loadTestsFromName()
+
+    ### Tests for TestLoader.loadTestsFromNames()
+    ################################################################
+
+    # "Similar to loadTestsFromName(), but takes a sequence of names rather
+    # than a single name."
+    #
+    # What happens if that sequence of names is empty?
+    def test_loadTestsFromNames__empty_name_list(self):
+        loader = unittest.TestLoader()
+
+        suite = loader.loadTestsFromNames([])
+        self.assertIsInstance(suite, loader.suiteClass)
+        self.assertEqual(list(suite), [])
+
+    # "Similar to loadTestsFromName(), but takes a sequence of names rather
+    # than a single name."
+    # ...
+    # "The method optionally resolves name relative to the given module"
+    #
+    # What happens if that sequence of names is empty?
+    #
+    # XXX Should this raise a ValueError or just return an empty TestSuite?
+    def test_loadTestsFromNames__relative_empty_name_list(self):
+        loader = unittest.TestLoader()
+
+        suite = loader.loadTestsFromNames([], unittest)
+        self.assertIsInstance(suite, loader.suiteClass)
+        self.assertEqual(list(suite), [])
+
+    # "The specifier name is a ``dotted name'' that may resolve either to
+    # a module, a test case class, a TestSuite instance, a test method
+    # within a test case class, or a callable object which returns a
+    # TestCase or TestSuite instance."
+    #
+    # Is ValueError raised in response to an empty name?
+    def test_loadTestsFromNames__empty_name(self):
+        loader = unittest.TestLoader()
+
+        try:
+            loader.loadTestsFromNames([''])
+        except ValueError as e:
+            self.assertEqual(str(e), "Empty module name")
+        else:
+            self.fail("TestLoader.loadTestsFromNames failed to raise ValueError")
+
+    # "The specifier name is a ``dotted name'' that may resolve either to
+    # a module, a test case class, a TestSuite instance, a test method
+    # within a test case class, or a callable object which returns a
+    # TestCase or TestSuite instance."
+    #
+    # What happens when presented with an impossible module name?
+    def test_loadTestsFromNames__malformed_name(self):
+        loader = unittest.TestLoader()
+
+        # XXX Should this raise ValueError or ImportError?
+        try:
+            loader.loadTestsFromNames(['abc () //'])
+        except ValueError:
+            pass
+        except ImportError:
+            pass
+        else:
+            self.fail("TestLoader.loadTestsFromNames failed to raise ValueError")
+
+    # "The specifier name is a ``dotted name'' that may resolve either to
+    # a module, a test case class, a TestSuite instance, a test method
+    # within a test case class, or a callable object which returns a
+    # TestCase or TestSuite instance."
+    #
+    # What happens when no module can be found for the given name?
+    def test_loadTestsFromNames__unknown_module_name(self):
+        loader = unittest.TestLoader()
+
+        try:
+            loader.loadTestsFromNames(['sdasfasfasdf'])
+        except ImportError as e:
+            self.assertEqual(str(e), "No module named sdasfasfasdf")
+        else:
+            self.fail("TestLoader.loadTestsFromNames failed to raise ImportError")
+
+    # "The specifier name is a ``dotted name'' that may resolve either to
+    # a module, a test case class, a TestSuite instance, a test method
+    # within a test case class, or a callable object which returns a
+    # TestCase or TestSuite instance."
+    #
+    # What happens when the module can be found, but not the attribute?
+    def test_loadTestsFromNames__unknown_attr_name(self):
+        loader = unittest.TestLoader()
+
+        try:
+            loader.loadTestsFromNames(['unittest.sdasfasfasdf', 'unittest'])
+        except AttributeError as e:
+            self.assertEqual(str(e), "'module' object has no attribute 'sdasfasfasdf'")
+        else:
+            self.fail("TestLoader.loadTestsFromNames failed to raise AttributeError")
+
+    # "The specifier name is a ``dotted name'' that may resolve either to
+    # a module, a test case class, a TestSuite instance, a test method
+    # within a test case class, or a callable object which returns a
+    # TestCase or TestSuite instance."
+    # ...
+    # "The method optionally resolves name relative to the given module"
+    #
+    # What happens when given an unknown attribute on a specified `module`
+    # argument?
+    def test_loadTestsFromNames__unknown_name_relative_1(self):
+        loader = unittest.TestLoader()
+
+        try:
+            loader.loadTestsFromNames(['sdasfasfasdf'], unittest)
+        except AttributeError as e:
+            self.assertEqual(str(e), "'module' object has no attribute 'sdasfasfasdf'")
+        else:
+            self.fail("TestLoader.loadTestsFromName failed to raise AttributeError")
+
+    # "The specifier name is a ``dotted name'' that may resolve either to
+    # a module, a test case class, a TestSuite instance, a test method
+    # within a test case class, or a callable object which returns a
+    # TestCase or TestSuite instance."
+    # ...
+    # "The method optionally resolves name relative to the given module"
+    #
+    # Do unknown attributes (relative to a provided module) still raise an
+    # exception even in the presence of valid attribute names?
+    def test_loadTestsFromNames__unknown_name_relative_2(self):
+        loader = unittest.TestLoader()
+
+        try:
+            loader.loadTestsFromNames(['TestCase', 'sdasfasfasdf'], unittest)
+        except AttributeError as e:
+            self.assertEqual(str(e), "'module' object has no attribute 'sdasfasfasdf'")
+        else:
+            self.fail("TestLoader.loadTestsFromName failed to raise AttributeError")
+
+    # "The specifier name is a ``dotted name'' that may resolve either to
+    # a module, a test case class, a TestSuite instance, a test method
+    # within a test case class, or a callable object which returns a
+    # TestCase or TestSuite instance."
+    # ...
+    # "The method optionally resolves name relative to the given module"
+    #
+    # What happens when faced with the empty string?
+    #
+    # XXX This currently raises AttributeError, though ValueError is probably
+    # more appropriate
+    def test_loadTestsFromNames__relative_empty_name(self):
+        loader = unittest.TestLoader()
+
+        try:
+            loader.loadTestsFromNames([''], unittest)
+        except AttributeError:
+            pass
+        else:
+            self.fail("Failed to raise ValueError")
+
+    # "The specifier name is a ``dotted name'' that may resolve either to
+    # a module, a test case class, a TestSuite instance, a test method
+    # within a test case class, or a callable object which returns a
+    # TestCase or TestSuite instance."
+    # ...
+    # "The method optionally resolves name relative to the given module"
+    #
+    # What happens when presented with an impossible attribute name?
+    def test_loadTestsFromNames__relative_malformed_name(self):
+        loader = unittest.TestLoader()
+
+        # XXX Should this raise AttributeError or ValueError?
+        try:
+            loader.loadTestsFromNames(['abc () //'], unittest)
+        except AttributeError:
+            pass
+        except ValueError:
+            pass
+        else:
+            self.fail("TestLoader.loadTestsFromNames failed to raise ValueError")
+
+    # "The method optionally resolves name relative to the given module"
+    #
+    # Does loadTestsFromNames() make sure the provided `module` is in fact
+    # a module?
+    #
+    # XXX This validation is currently not done. This flexibility should
+    # either be documented or a TypeError should be raised.
+    def test_loadTestsFromNames__relative_not_a_module(self):
+        class MyTestCase(unittest.TestCase):
+            def test(self):
+                pass
+
+        class NotAModule(object):
+            test_2 = MyTestCase
+
+        loader = unittest.TestLoader()
+        suite = loader.loadTestsFromNames(['test_2'], NotAModule)
+
+        reference = [unittest.TestSuite([MyTestCase('test')])]
+        self.assertEqual(list(suite), reference)
+
+    # "The specifier name is a ``dotted name'' that may resolve either to
+    # a module, a test case class, a TestSuite instance, a test method
+    # within a test case class, or a callable object which returns a
+    # TestCase or TestSuite instance."
+    #
+    # Does it raise an exception if the name resolves to an invalid
+    # object?
+    def test_loadTestsFromNames__relative_bad_object(self):
+        m = types.ModuleType('m')
+        m.testcase_1 = object()
+
+        loader = unittest.TestLoader()
+        try:
+            loader.loadTestsFromNames(['testcase_1'], m)
+        except TypeError:
+            pass
+        else:
+            self.fail("Should have raised TypeError")
+
+    # "The specifier name is a ``dotted name'' that may resolve ... to
+    # ... a test case class"
+    def test_loadTestsFromNames__relative_TestCase_subclass(self):
+        m = types.ModuleType('m')
+        class MyTestCase(unittest.TestCase):
+            def test(self):
+                pass
+        m.testcase_1 = MyTestCase
+
+        loader = unittest.TestLoader()
+        suite = loader.loadTestsFromNames(['testcase_1'], m)
+        self.assertIsInstance(suite, loader.suiteClass)
+
+        expected = loader.suiteClass([MyTestCase('test')])
+        self.assertEqual(list(suite), [expected])
+
+    # "The specifier name is a ``dotted name'' that may resolve ... to
+    # ... a TestSuite instance"
+    def test_loadTestsFromNames__relative_TestSuite(self):
+        m = types.ModuleType('m')
+        class MyTestCase(unittest.TestCase):
+            def test(self):
+                pass
+        m.testsuite = unittest.TestSuite([MyTestCase('test')])
+
+        loader = unittest.TestLoader()
+        suite = loader.loadTestsFromNames(['testsuite'], m)
+        self.assertIsInstance(suite, loader.suiteClass)
+
+        self.assertEqual(list(suite), [m.testsuite])
+
+    # "The specifier name is a ``dotted name'' that may resolve ... to ... a
+    # test method within a test case class"
+    def test_loadTestsFromNames__relative_testmethod(self):
+        m = types.ModuleType('m')
+        class MyTestCase(unittest.TestCase):
+            def test(self):
+                pass
+        m.testcase_1 = MyTestCase
+
+        loader = unittest.TestLoader()
+        suite = loader.loadTestsFromNames(['testcase_1.test'], m)
+        self.assertIsInstance(suite, loader.suiteClass)
+
+        ref_suite = unittest.TestSuite([MyTestCase('test')])
+        self.assertEqual(list(suite), [ref_suite])
+
+    # "The specifier name is a ``dotted name'' that may resolve ... to ... a
+    # test method within a test case class"
+    #
+    # Does the method gracefully handle names that initially look like they
+    # resolve to "a test method within a test case class" but don't?
+    def test_loadTestsFromNames__relative_invalid_testmethod(self):
+        m = types.ModuleType('m')
+        class MyTestCase(unittest.TestCase):
+            def test(self):
+                pass
+        m.testcase_1 = MyTestCase
+
+        loader = unittest.TestLoader()
+        try:
+            loader.loadTestsFromNames(['testcase_1.testfoo'], m)
+        except AttributeError as e:
+            self.assertEqual(str(e), "type object 'MyTestCase' has no attribute 'testfoo'")
+        else:
+            self.fail("Failed to raise AttributeError")
+
+    # "The specifier name is a ``dotted name'' that may resolve ... to
+    # ... a callable object which returns a ... TestSuite instance"
+    def test_loadTestsFromNames__callable__TestSuite(self):
+        m = types.ModuleType('m')
+        testcase_1 = unittest.FunctionTestCase(lambda: None)
+        testcase_2 = unittest.FunctionTestCase(lambda: None)
+        def return_TestSuite():
+            return unittest.TestSuite([testcase_1, testcase_2])
+        m.return_TestSuite = return_TestSuite
+
+        loader = unittest.TestLoader()
+        suite = loader.loadTestsFromNames(['return_TestSuite'], m)
+        self.assertIsInstance(suite, loader.suiteClass)
+
+        expected = unittest.TestSuite([testcase_1, testcase_2])
+        self.assertEqual(list(suite), [expected])
+
+    # "The specifier name is a ``dotted name'' that may resolve ... to
+    # ... a callable object which returns a TestCase ... instance"
+    def test_loadTestsFromNames__callable__TestCase_instance(self):
+        m = types.ModuleType('m')
+        testcase_1 = unittest.FunctionTestCase(lambda: None)
+        def return_TestCase():
+            return testcase_1
+        m.return_TestCase = return_TestCase
+
+        loader = unittest.TestLoader()
+        suite = loader.loadTestsFromNames(['return_TestCase'], m)
+        self.assertIsInstance(suite, loader.suiteClass)
+
+        ref_suite = unittest.TestSuite([testcase_1])
+        self.assertEqual(list(suite), [ref_suite])
+
+    # "The specifier name is a ``dotted name'' that may resolve ... to
+    # ... a callable object which returns a TestCase or TestSuite instance"
+    #
+    # Are staticmethods handled correctly?
+    def test_loadTestsFromNames__callable__call_staticmethod(self):
+        m = types.ModuleType('m')
+        class Test1(unittest.TestCase):
+            def test(self):
+                pass
+
+        testcase_1 = Test1('test')
+        class Foo(unittest.TestCase):
+            @staticmethod
+            def foo():
+                return testcase_1
+        m.Foo = Foo
+
+        loader = unittest.TestLoader()
+        suite = loader.loadTestsFromNames(['Foo.foo'], m)
+        self.assertIsInstance(suite, loader.suiteClass)
+
+        ref_suite = unittest.TestSuite([testcase_1])
+        self.assertEqual(list(suite), [ref_suite])
+
+    # "The specifier name is a ``dotted name'' that may resolve ... to
+    # ... a callable object which returns a TestCase or TestSuite instance"
+    #
+    # What happens when the callable returns something else?
+    def test_loadTestsFromNames__callable__wrong_type(self):
+        m = types.ModuleType('m')
+        def return_wrong():
+            return 6
+        m.return_wrong = return_wrong
+
+        loader = unittest.TestLoader()
+        try:
+            suite = loader.loadTestsFromNames(['return_wrong'], m)
+        except TypeError:
+            pass
+        else:
+            self.fail("TestLoader.loadTestsFromNames failed to raise TypeError")
+
+    # "The specifier can refer to modules and packages which have not been
+    # imported; they will be imported as a side-effect"
+    def test_loadTestsFromNames__module_not_loaded(self):
+        # We're going to try to load this module as a side-effect, so it
+        # better not be loaded before we try.
+        #
+        module_name = 'unittest2.test.dummy'
+        sys.modules.pop(module_name, None)
+
+        loader = unittest.TestLoader()
+        try:
+            suite = loader.loadTestsFromNames([module_name])
+
+            self.assertIsInstance(suite, loader.suiteClass)
+            self.assertEqual(list(suite), [unittest.TestSuite()])
+
+            # module should now be loaded, thanks to loadTestsFromName()
+            self.assertIn(module_name, sys.modules)
+        finally:
+            if module_name in sys.modules:
+                del sys.modules[module_name]
+
+    ################################################################
+    ### /Tests for TestLoader.loadTestsFromNames()
+
+    ### Tests for TestLoader.getTestCaseNames()
+    ################################################################
+
+    # "Return a sorted sequence of method names found within testCaseClass"
+    #
+    # Test.foobar is defined to make sure getTestCaseNames() respects
+    # loader.testMethodPrefix
+    def test_getTestCaseNames(self):
+        class Test(unittest.TestCase):
+            def test_1(self): pass
+            def test_2(self): pass
+            def foobar(self): pass
+
+        loader = unittest.TestLoader()
+
+        self.assertEqual(loader.getTestCaseNames(Test), ['test_1', 'test_2'])
+
+    # "Return a sorted sequence of method names found within testCaseClass"
+    #
+    # Does getTestCaseNames() behave appropriately if no tests are found?
+    def test_getTestCaseNames__no_tests(self):
+        class Test(unittest.TestCase):
+            def foobar(self): pass
+
+        loader = unittest.TestLoader()
+
+        self.assertEqual(loader.getTestCaseNames(Test), [])
+
+    # "Return a sorted sequence of method names found within testCaseClass"
+    #
+    # Are not-TestCases handled gracefully?
+    #
+    # XXX This should raise a TypeError, not return a list
+    #
+    # XXX It's too late in the 2.5 release cycle to fix this, but it should
+    # probably be revisited for 2.6
+    def test_getTestCaseNames__not_a_TestCase(self):
+        class BadCase(int):
+            def test_foo(self):
+                pass
+
+        loader = unittest.TestLoader()
+        names = loader.getTestCaseNames(BadCase)
+
+        self.assertEqual(names, ['test_foo'])
+
+    # "Return a sorted sequence of method names found within testCaseClass"
+    #
+    # Make sure inherited names are handled.
+    #
+    # TestP.foobar is defined to make sure getTestCaseNames() respects
+    # loader.testMethodPrefix
+    def test_getTestCaseNames__inheritance(self):
+        class TestP(unittest.TestCase):
+            def test_1(self): pass
+            def test_2(self): pass
+            def foobar(self): pass
+
+        class TestC(TestP):
+            def test_1(self): pass
+            def test_3(self): pass
+
+        loader = unittest.TestLoader()
+
+        names = ['test_1', 'test_2', 'test_3']
+        self.assertEqual(loader.getTestCaseNames(TestC), names)
+
+    ################################################################
+    ### /Tests for TestLoader.getTestCaseNames()
+
+    ### Tests for TestLoader.testMethodPrefix
+    ################################################################
+
+    # "String giving the prefix of method names which will be interpreted as
+    # test methods"
+    #
+    # Implicit in the documentation is that testMethodPrefix is respected by
+    # all loadTestsFrom* methods.
+    def test_testMethodPrefix__loadTestsFromTestCase(self):
+        class Foo(unittest.TestCase):
+            def test_1(self): pass
+            def test_2(self): pass
+            def foo_bar(self): pass
+
+        tests_1 = unittest.TestSuite([Foo('foo_bar')])
+        tests_2 = unittest.TestSuite([Foo('test_1'), Foo('test_2')])
+
+        loader = unittest.TestLoader()
+        loader.testMethodPrefix = 'foo'
+        self.assertEqual(loader.loadTestsFromTestCase(Foo), tests_1)
+
+        loader.testMethodPrefix = 'test'
+        self.assertEqual(loader.loadTestsFromTestCase(Foo), tests_2)
+
+    # "String giving the prefix of method names which will be interpreted as
+    # test methods"
+    #
+    # Implicit in the documentation is that testMethodPrefix is respected by
+    # all loadTestsFrom* methods.
+    def test_testMethodPrefix__loadTestsFromModule(self):
+        m = types.ModuleType('m')
+        class Foo(unittest.TestCase):
+            def test_1(self): pass
+            def test_2(self): pass
+            def foo_bar(self): pass
+        m.Foo = Foo
+
+        tests_1 = [unittest.TestSuite([Foo('foo_bar')])]
+        tests_2 = [unittest.TestSuite([Foo('test_1'), Foo('test_2')])]
+
+        loader = unittest.TestLoader()
+        loader.testMethodPrefix = 'foo'
+        self.assertEqual(list(loader.loadTestsFromModule(m)), tests_1)
+
+        loader.testMethodPrefix = 'test'
+        self.assertEqual(list(loader.loadTestsFromModule(m)), tests_2)
+
+    # "String giving the prefix of method names which will be interpreted as
+    # test methods"
+    #
+    # Implicit in the documentation is that testMethodPrefix is respected by
+    # all loadTestsFrom* methods.
+    def test_testMethodPrefix__loadTestsFromName(self):
+        m = types.ModuleType('m')
+        class Foo(unittest.TestCase):
+            def test_1(self): pass
+            def test_2(self): pass
+            def foo_bar(self): pass
+        m.Foo = Foo
+
+        tests_1 = unittest.TestSuite([Foo('foo_bar')])
+        tests_2 = unittest.TestSuite([Foo('test_1'), Foo('test_2')])
+
+        loader = unittest.TestLoader()
+        loader.testMethodPrefix = 'foo'
+        self.assertEqual(loader.loadTestsFromName('Foo', m), tests_1)
+
+        loader.testMethodPrefix = 'test'
+        self.assertEqual(loader.loadTestsFromName('Foo', m), tests_2)
+
+    # "String giving the prefix of method names which will be interpreted as
+    # test methods"
+    #
+    # Implicit in the documentation is that testMethodPrefix is respected by
+    # all loadTestsFrom* methods.
+    def test_testMethodPrefix__loadTestsFromNames(self):
+        m = types.ModuleType('m')
+        class Foo(unittest.TestCase):
+            def test_1(self): pass
+            def test_2(self): pass
+            def foo_bar(self): pass
+        m.Foo = Foo
+
+        tests_1 = unittest.TestSuite([unittest.TestSuite([Foo('foo_bar')])])
+        tests_2 = unittest.TestSuite([Foo('test_1'), Foo('test_2')])
+        tests_2 = unittest.TestSuite([tests_2])
+
+        loader = unittest.TestLoader()
+        loader.testMethodPrefix = 'foo'
+        self.assertEqual(loader.loadTestsFromNames(['Foo'], m), tests_1)
+
+        loader.testMethodPrefix = 'test'
+        self.assertEqual(loader.loadTestsFromNames(['Foo'], m), tests_2)
+
+    # "The default value is 'test'"
+    def test_testMethodPrefix__default_value(self):
+        loader = unittest.TestLoader()
+        self.assertEqual(loader.testMethodPrefix, 'test')
+
+    ################################################################
+    ### /Tests for TestLoader.testMethodPrefix
+
+    ### Tests for TestLoader.sortTestMethodsUsing
+    ################################################################
+
+    # "Function to be used to compare method names when sorting them in
+    # getTestCaseNames() and all the loadTestsFromX() methods"
+    def test_sortTestMethodsUsing__loadTestsFromTestCase(self):
+        def reversed_cmp(x, y):
+            return -((x > y) - (x < y))
+
+        class Foo(unittest.TestCase):
+            def test_1(self): pass
+            def test_2(self): pass
+
+        loader = unittest.TestLoader()
+        loader.sortTestMethodsUsing = reversed_cmp
+
+        tests = loader.suiteClass([Foo('test_2'), Foo('test_1')])
+        self.assertEqual(loader.loadTestsFromTestCase(Foo), tests)
+
+    # "Function to be used to compare method names when sorting them in
+    # getTestCaseNames() and all the loadTestsFromX() methods"
+    def test_sortTestMethodsUsing__loadTestsFromModule(self):
+        def reversed_cmp(x, y):
+            return -((x > y) - (x < y))
+
+        m = types.ModuleType('m')
+        class Foo(unittest.TestCase):
+            def test_1(self): pass
+            def test_2(self): pass
+        m.Foo = Foo
+
+        loader = unittest.TestLoader()
+        loader.sortTestMethodsUsing = reversed_cmp
+
+        tests = [loader.suiteClass([Foo('test_2'), Foo('test_1')])]
+        self.assertEqual(list(loader.loadTestsFromModule(m)), tests)
+
+    # "Function to be used to compare method names when sorting them in
+    # getTestCaseNames() and all the loadTestsFromX() methods"
+    def test_sortTestMethodsUsing__loadTestsFromName(self):
+        def reversed_cmp(x, y):
+            return -((x > y) - (x < y))
+
+        m = types.ModuleType('m')
+        class Foo(unittest.TestCase):
+            def test_1(self): pass
+            def test_2(self): pass
+        m.Foo = Foo
+
+        loader = unittest.TestLoader()
+        loader.sortTestMethodsUsing = reversed_cmp
+
+        tests = loader.suiteClass([Foo('test_2'), Foo('test_1')])
+        self.assertEqual(loader.loadTestsFromName('Foo', m), tests)
+
+    # "Function to be used to compare method names when sorting them in
+    # getTestCaseNames() and all the loadTestsFromX() methods"
+    def test_sortTestMethodsUsing__loadTestsFromNames(self):
+        def reversed_cmp(x, y):
+            return -((x > y) - (x < y))
+
+        m = types.ModuleType('m')
+        class Foo(unittest.TestCase):
+            def test_1(self): pass
+            def test_2(self): pass
+        m.Foo = Foo
+
+        loader = unittest.TestLoader()
+        loader.sortTestMethodsUsing = reversed_cmp
+
+        tests = [loader.suiteClass([Foo('test_2'), Foo('test_1')])]
+        self.assertEqual(list(loader.loadTestsFromNames(['Foo'], m)), tests)
+
+    # "Function to be used to compare method names when sorting them in
+    # getTestCaseNames()"
+    #
+    # Does it actually affect getTestCaseNames()?
+    def test_sortTestMethodsUsing__getTestCaseNames(self):
+        def reversed_cmp(x, y):
+            return -((x > y) - (x < y))
+
+        class Foo(unittest.TestCase):
+            def test_1(self): pass
+            def test_2(self): pass
+
+        loader = unittest.TestLoader()
+        loader.sortTestMethodsUsing = reversed_cmp
+
+        test_names = ['test_2', 'test_1']
+        self.assertEqual(loader.getTestCaseNames(Foo), test_names)
+
+    # "The default value is the built-in cmp() function"
+    # Since cmp is now defunct, we simply verify that the results
+    # occur in the same order as they would with the default sort.
+    def test_sortTestMethodsUsing__default_value(self):
+        loader = unittest.TestLoader()
+
+        class Foo(unittest.TestCase):
+            def test_2(self): pass
+            def test_3(self): pass
+            def test_1(self): pass
+
+        test_names = ['test_2', 'test_3', 'test_1']
+        self.assertEqual(loader.getTestCaseNames(Foo), sorted(test_names))
+
+
+    # "it can be set to None to disable the sort."
+    #
+    # XXX How is this different from reassigning cmp? Are the tests returned
+    # in a random order or something? This behaviour should die
+    def test_sortTestMethodsUsing__None(self):
+        class Foo(unittest.TestCase):
+            def test_1(self): pass
+            def test_2(self): pass
+
+        loader = unittest.TestLoader()
+        loader.sortTestMethodsUsing = None
+
+        test_names = ['test_2', 'test_1']
+        self.assertEqual(set(loader.getTestCaseNames(Foo)), set(test_names))
+
+    ################################################################
+    ### /Tests for TestLoader.sortTestMethodsUsing
+
+    ### Tests for TestLoader.suiteClass
+    ################################################################
+
+    # "Callable object that constructs a test suite from a list of tests."
+    def test_suiteClass__loadTestsFromTestCase(self):
+        class Foo(unittest.TestCase):
+            def test_1(self): pass
+            def test_2(self): pass
+            def foo_bar(self): pass
+
+        tests = [Foo('test_1'), Foo('test_2')]
+
+        loader = unittest.TestLoader()
+        loader.suiteClass = list
+        self.assertEqual(loader.loadTestsFromTestCase(Foo), tests)
+
+    # It is implicit in the documentation for TestLoader.suiteClass that
+    # all TestLoader.loadTestsFrom* methods respect it. Let's make sure
+    def test_suiteClass__loadTestsFromModule(self):
+        m = types.ModuleType('m')
+        class Foo(unittest.TestCase):
+            def test_1(self): pass
+            def test_2(self): pass
+            def foo_bar(self): pass
+        m.Foo = Foo
+
+        tests = [[Foo('test_1'), Foo('test_2')]]
+
+        loader = unittest.TestLoader()
+        loader.suiteClass = list
+        self.assertEqual(loader.loadTestsFromModule(m), tests)
+
+    # It is implicit in the documentation for TestLoader.suiteClass that
+    # all TestLoader.loadTestsFrom* methods respect it. Let's make sure
+    def test_suiteClass__loadTestsFromName(self):
+        m = types.ModuleType('m')
+        class Foo(unittest.TestCase):
+            def test_1(self): pass
+            def test_2(self): pass
+            def foo_bar(self): pass
+        m.Foo = Foo
+
+        tests = [Foo('test_1'), Foo('test_2')]
+
+        loader = unittest.TestLoader()
+        loader.suiteClass = list
+        self.assertEqual(loader.loadTestsFromName('Foo', m), tests)
+
+    # It is implicit in the documentation for TestLoader.suiteClass that
+    # all TestLoader.loadTestsFrom* methods respect it. Let's make sure
+    def test_suiteClass__loadTestsFromNames(self):
+        m = types.ModuleType('m')
+        class Foo(unittest.TestCase):
+            def test_1(self): pass
+            def test_2(self): pass
+            def foo_bar(self): pass
+        m.Foo = Foo
+
+        tests = [[Foo('test_1'), Foo('test_2')]]
+
+        loader = unittest.TestLoader()
+        loader.suiteClass = list
+        self.assertEqual(loader.loadTestsFromNames(['Foo'], m), tests)
+
+    # "The default value is the TestSuite class"
+    def test_suiteClass__default_value(self):
+        loader = unittest.TestLoader()
+        self.assertTrue(loader.suiteClass is unittest.TestSuite)
+
+    def testBaseClassInheritance(self):
+        import unittest as unittestorig
+        self.assertTrue(issubclass(unittest.TestLoader, unittestorig.TestLoader))
diff -u -x '*.pyc' --recursive --new-file cpython/Lib/unittest/test/test_program.py unittest2/test/test_program.py
--- cpython/Lib/unittest/test/test_program.py	2011-03-24 02:43:51.000000000 -0400
+++ unittest2/test/test_program.py	2011-03-25 21:38:23.000000000 -0400
@@ -2,7 +2,7 @@
 
 import os
 import sys
-import unittest
+import unittest2 as unittest
 
 
 class Test_TestProgram(unittest.TestCase):
@@ -19,7 +19,7 @@
             self.assertEqual(start_dir, expectedPath)
             return tests
         loader._find_tests = _find_tests
-        suite = loader.discover('unittest.test')
+        suite = loader.discover('unittest2.test')
         self.assertTrue(self.wasRun)
         self.assertEqual(suite._tests, tests)
 
@@ -91,6 +91,9 @@
             testRunner=unittest.TextTestRunner(stream=io.StringIO()),
             testLoader=self.FooBarLoader())
 
+    def testBaseClassInheritance(self):
+        import unittest as unittestorig
+        self.assertTrue(issubclass(unittest.TestProgram, unittestorig.TestProgram))
 
 class InitialisableProgram(unittest.TestProgram):
     exit = False
@@ -255,7 +258,7 @@
         self.assertIs(program.result, RESULT)
 
     def testCatchBreakInstallsHandler(self):
-        module = sys.modules['unittest.main']
+        module = sys.modules['unittest2.main']
         original = module.installHandler
         def restore():
             module.installHandler = original
@@ -353,6 +356,5 @@
         # for invalid filenames should we raise a useful error rather than
         # leaving the current error message (import of filename fails) in place?
 
-
 if __name__ == '__main__':
     unittest.main()
diff -u -x '*.pyc' --recursive --new-file cpython/Lib/unittest/test/test_result.py unittest2/test/test_result.py
--- cpython/Lib/unittest/test/test_result.py	2011-03-24 02:43:51.000000000 -0400
+++ unittest2/test/test_result.py	2011-03-25 21:38:23.000000000 -0400
@@ -2,11 +2,10 @@
 import sys
 import textwrap
 
-from test import support
-
 import traceback
-import unittest
+import unittest2 as unittest
 
+from .support import check_warnings
 
 class Test_TestResult(unittest.TestCase):
     # Note: there are not separate tests for TestResult.wasSuccessful(),
@@ -294,6 +293,10 @@
             self.assertTrue(result.failfast)
         result = runner.run(test)
 
+    def testBaseClassInheritance(self):
+        import unittest as unittestorig
+        self.assertTrue(issubclass(unittest.TestResult, unittestorig.TestResult))
+
 
 classDict = dict(unittest.TestResult.__dict__)
 for m in ('addSkip', 'addExpectedFailure', 'addUnexpectedSuccess',
@@ -313,7 +316,7 @@
 class Test_OldTestResult(unittest.TestCase):
 
     def assertOldResultWarning(self, test, failures):
-        with support.check_warnings(("TestResult has no add.+ method,",
+        with check_warnings(("TestResult has no add.+ method,",
                                      RuntimeWarning)):
             result = OldResult()
             test.run(result)
diff -u -x '*.pyc' --recursive --new-file cpython/Lib/unittest/test/test_runner.py unittest2/test/test_runner.py
--- cpython/Lib/unittest/test/test_runner.py	2011-03-24 02:43:51.000000000 -0400
+++ unittest2/test/test_runner.py	2011-03-25 21:38:23.000000000 -0400
@@ -4,7 +4,7 @@
 import pickle
 import subprocess
 
-import unittest
+import unittest2 as unittest
 
 from .support import LoggingResult, ResultWithNoStartTestRunStopTestRun
 
@@ -222,6 +222,8 @@
         expected = ['startTestRun', 'stopTestRun']
         self.assertEqual(events, expected)
 
+    @unittest.skipIf(sys.version_info[:2] < (3, 2), 
+                      "io.StringIO() not pickleable until Python 3.2")
     def test_pickle_unpickle(self):
         # Issue #7197: a TextTestRunner should be (un)pickleable. This is
         # required by test_multiprocessing under Windows (in verbose mode).
diff -u -x '*.pyc' --recursive --new-file cpython/Lib/unittest/test/test_setups.py unittest2/test/test_setups.py
--- cpython/Lib/unittest/test/test_setups.py	2011-03-24 02:43:51.000000000 -0400
+++ unittest2/test/test_setups.py	2011-03-25 21:38:23.000000000 -0400
@@ -1,7 +1,7 @@
 import io
 import sys
 
-import unittest
+import unittest2 as unittest
 
 
 def resultFactory(*_):
diff -u -x '*.pyc' --recursive --new-file cpython/Lib/unittest/test/test_skipping.py unittest2/test/test_skipping.py
--- cpython/Lib/unittest/test/test_skipping.py	2011-03-24 02:43:51.000000000 -0400
+++ unittest2/test/test_skipping.py	2011-03-25 21:38:23.000000000 -0400
@@ -1,4 +1,4 @@
-import unittest
+import unittest2 as unittest
 
 from .support import LoggingResult
 
diff -u -x '*.pyc' --recursive --new-file cpython/Lib/unittest/test/test_suite.py unittest2/test/test_suite.py
--- cpython/Lib/unittest/test/test_suite.py	2011-03-24 02:43:51.000000000 -0400
+++ unittest2/test/test_suite.py	2011-03-25 21:38:23.000000000 -0400
@@ -1,4 +1,4 @@
-import unittest
+import unittest2 as unittest
 
 import sys
 from .support import LoggingResult, TestEquality
@@ -362,6 +362,10 @@
         # reusing results should be permitted even if abominable
         self.assertFalse(result._testRunEntered)
 
+    def testBaseClassInheritance(self):
+        import unittest as unittestorig
+        self.assertTrue(issubclass(unittest.TestSuite, unittestorig.TestSuite))
+
 
 
 if __name__ == '__main__':
diff -u -x '*.pyc' --recursive --new-file cpython/Lib/unittest/test/_test_warnings.py unittest2/test/_test_warnings.py
--- cpython/Lib/unittest/test/_test_warnings.py	2011-03-24 02:43:51.000000000 -0400
+++ unittest2/test/_test_warnings.py	2011-03-25 21:38:23.000000000 -0400
@@ -12,7 +12,7 @@
 
 import io
 import sys
-import unittest
+import unittest2 as unittest
 import warnings
 
 def warnfun():
diff -u -x '*.pyc' --recursive --new-file cpython/Lib/unittest/util.py unittest2/util.py
--- cpython/Lib/unittest/util.py	2011-03-24 02:43:51.000000000 -0400
+++ unittest2/util.py	2011-03-25 21:38:23.000000000 -0400
@@ -1,6 +1,7 @@
 """Various utility functions."""
 
-from collections import namedtuple, OrderedDict
+from collections import namedtuple
+from .compatibility import OrderedDict
 
 __unittest = True
 
