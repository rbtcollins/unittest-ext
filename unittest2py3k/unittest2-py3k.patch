diff -u -x '*.pyc' --recursive --new-file cpython/Lib/unittest/case.py unittest2/case.py
--- cpython/Lib/unittest/case.py	2011-03-24 02:43:51.000000000 -0400
+++ unittest2/case.py	2011-03-25 21:38:23.000000000 -0400
@@ -7,6 +7,9 @@
 import re
 import warnings
 import collections
+import unittest
+
+from .compatibility import Counter
 
 from . import result
 from .util import (strclass, safe_repr, sorted_list_difference,
@@ -223,7 +226,7 @@
         return default
 
 
-class TestCase(object):
+class TestCase(unittest.TestCase):
     """A class whose instances are single test cases.
 
     By default, the test code itself should be placed in a method named
@@ -953,8 +956,8 @@
         """
         first_seq, second_seq = list(first), list(second)
         try:
-            first = collections.Counter(first_seq)
-            second = collections.Counter(second_seq)
+            first = Counter(first_seq)
+            second = Counter(second_seq)
         except TypeError:
             # Handle case with unhashable elements
             differences = _count_diff_all_purpose(first_seq, second_seq)
@@ -971,6 +974,9 @@
             msg = self._formatMessage(msg, standardMsg)
             self.fail(msg)
 
+    # Alias for backwards compatibility
+    assertItemsEqual = assertCountEqual
+
     def assertMultiLineEqual(self, first, second, msg=None):
         """Assert that two multi-line strings are equal."""
         self.assertIsInstance(first, str, 'First argument is not a string')
diff -u -x '*.pyc' --recursive --new-file cpython/Lib/unittest/case.py.orig unittest2/case.py.orig
--- cpython/Lib/unittest/case.py.orig	1969-12-31 19:00:00.000000000 -0500
+++ unittest2/case.py.orig	2011-03-25 21:38:23.000000000 -0400
@@ -0,0 +1,1183 @@
+"""Test case implementation"""
+
+import sys
+import functools
+import difflib
+import pprint
+import re
+import warnings
+import collections
+
+from . import result
+from .util import (strclass, safe_repr, sorted_list_difference,
+                   unorderable_list_difference, _count_diff_all_purpose,
+                   _count_diff_hashable)
+
+__unittest = True
+
+
+DIFF_OMITTED = ('\nDiff is %s characters long. '
+                 'Set self.maxDiff to None to see it.')
+
+class SkipTest(Exception):
+    """
+    Raise this exception in a test to skip it.
+
+    Usually you can use TestResult.skip() or one of the skipping decorators
+    instead of raising this directly.
+    """
+
+class _ExpectedFailure(Exception):
+    """
+    Raise this when a test is expected to fail.
+
+    This is an implementation detail.
+    """
+
+    def __init__(self, exc_info):
+        super(_ExpectedFailure, self).__init__()
+        self.exc_info = exc_info
+
+class _UnexpectedSuccess(Exception):
+    """
+    The test was supposed to fail, but it didn't!
+    """
+
+
+class _Outcome(object):
+    def __init__(self):
+        self.success = True
+        self.skipped = None
+        self.unexpectedSuccess = None
+        self.expectedFailure = None
+        self.errors = []
+        self.failures = []
+
+
+def _id(obj):
+    return obj
+
+def skip(reason):
+    """
+    Unconditionally skip a test.
+    """
+    def decorator(test_item):
+        if not (isinstance(test_item, type) and issubclass(test_item, TestCase)):
+            @functools.wraps(test_item)
+            def skip_wrapper(*args, **kwargs):
+                raise SkipTest(reason)
+            test_item = skip_wrapper
+
+        test_item.__unittest_skip__ = True
+        test_item.__unittest_skip_why__ = reason
+        return test_item
+    return decorator
+
+def skipIf(condition, reason):
+    """
+    Skip a test if the condition is true.
+    """
+    if condition:
+        return skip(reason)
+    return _id
+
+def skipUnless(condition, reason):
+    """
+    Skip a test unless the condition is true.
+    """
+    if not condition:
+        return skip(reason)
+    return _id
+
+
+def expectedFailure(func):
+    @functools.wraps(func)
+    def wrapper(*args, **kwargs):
+        try:
+            func(*args, **kwargs)
+        except Exception:
+            raise _ExpectedFailure(sys.exc_info())
+        raise _UnexpectedSuccess
+    return wrapper
+
+
+class _AssertRaisesBaseContext(object):
+
+    def __init__(self, expected, test_case, callable_obj=None,
+                  expected_regex=None):
+        self.expected = expected
+        self.failureException = test_case.failureException
+        if callable_obj is not None:
+            try:
+                self.obj_name = callable_obj.__name__
+            except AttributeError:
+                self.obj_name = str(callable_obj)
+        else:
+            self.obj_name = None
+        if isinstance(expected_regex, (bytes, str)):
+            expected_regex = re.compile(expected_regex)
+        self.expected_regex = expected_regex
+
+
+class _AssertRaisesContext(_AssertRaisesBaseContext):
+    """A context manager used to implement TestCase.assertRaises* methods."""
+
+    def __enter__(self):
+        return self
+
+    def __exit__(self, exc_type, exc_value, tb):
+        if exc_type is None:
+            try:
+                exc_name = self.expected.__name__
+            except AttributeError:
+                exc_name = str(self.expected)
+            if self.obj_name:
+                raise self.failureException("{0} not raised by {1}"
+                    .format(exc_name, self.obj_name))
+            else:
+                raise self.failureException("{0} not raised"
+                    .format(exc_name))
+        if not issubclass(exc_type, self.expected):
+            # let unexpected exceptions pass through
+            return False
+        # store exception, without traceback, for later retrieval
+        self.exception = exc_value.with_traceback(None)
+        if self.expected_regex is None:
+            return True
+
+        expected_regex = self.expected_regex
+        if not expected_regex.search(str(exc_value)):
+            raise self.failureException('"%s" does not match "%s"' %
+                     (expected_regex.pattern, str(exc_value)))
+        return True
+
+
+class _AssertWarnsContext(_AssertRaisesBaseContext):
+    """A context manager used to implement TestCase.assertWarns* methods."""
+
+    def __enter__(self):
+        # The __warningregistry__'s need to be in a pristine state for tests
+        # to work properly.
+        for v in sys.modules.values():
+            if getattr(v, '__warningregistry__', None):
+                v.__warningregistry__ = {}
+        self.warnings_manager = warnings.catch_warnings(record=True)
+        self.warnings = self.warnings_manager.__enter__()
+        warnings.simplefilter("always", self.expected)
+        return self
+
+    def __exit__(self, exc_type, exc_value, tb):
+        self.warnings_manager.__exit__(exc_type, exc_value, tb)
+        if exc_type is not None:
+            # let unexpected exceptions pass through
+            return
+        try:
+            exc_name = self.expected.__name__
+        except AttributeError:
+            exc_name = str(self.expected)
+        first_matching = None
+        for m in self.warnings:
+            w = m.message
+            if not isinstance(w, self.expected):
+                continue
+            if first_matching is None:
+                first_matching = w
+            if (self.expected_regex is not None and
+                not self.expected_regex.search(str(w))):
+                continue
+            # store warning for later retrieval
+            self.warning = w
+            self.filename = m.filename
+            self.lineno = m.lineno
+            return
+        # Now we simply try to choose a helpful failure message
+        if first_matching is not None:
+            raise self.failureException('"%s" does not match "%s"' %
+                     (self.expected_regex.pattern, str(first_matching)))
+        if self.obj_name:
+            raise self.failureException("{0} not triggered by {1}"
+                .format(exc_name, self.obj_name))
+        else:
+            raise self.failureException("{0} not triggered"
+                .format(exc_name))
+
+
+class _TypeEqualityDict(object):
+
+    def __init__(self, testcase):
+        self.testcase = testcase
+        self._store = {}
+
+    def __setitem__(self, key, value):
+        self._store[key] = value
+
+    def __getitem__(self, key):
+        value = self._store[key]
+        if isinstance(value, str):
+            return getattr(self.testcase, value)
+        return value
+
+    def get(self, key, default=None):
+        if key in self._store:
+            return self[key]
+        return default
+
+
+class TestCase(object):
+    """A class whose instances are single test cases.
+
+    By default, the test code itself should be placed in a method named
+    'runTest'.
+
+    If the fixture may be used for many test cases, create as
+    many test methods as are needed. When instantiating such a TestCase
+    subclass, specify in the constructor arguments the name of the test method
+    that the instance is to execute.
+
+    Test authors should subclass TestCase for their own tests. Construction
+    and deconstruction of the test's environment ('fixture') can be
+    implemented by overriding the 'setUp' and 'tearDown' methods respectively.
+
+    If it is necessary to override the __init__ method, the base class
+    __init__ method must always be called. It is important that subclasses
+    should not change the signature of their __init__ method, since instances
+    of the classes are instantiated automatically by parts of the framework
+    in order to be run.
+    """
+
+    # This attribute determines which exception will be raised when
+    # the instance's assertion methods fail; test methods raising this
+    # exception will be deemed to have 'failed' rather than 'errored'
+
+    failureException = AssertionError
+
+    # This attribute determines whether long messages (including repr of
+    # objects used in assert methods) will be printed on failure in *addition*
+    # to any explicit message passed.
+
+    longMessage = True
+
+    # This attribute sets the maximum length of a diff in failure messages
+    # by assert methods using difflib. It is looked up as an instance attribute
+    # so can be configured by individual tests if required.
+
+    maxDiff = 80*8
+
+    # Attribute used by TestSuite for classSetUp
+
+    _classSetupFailed = False
+
+    def __init__(self, methodName='runTest'):
+        """Create an instance of the class that will use the named test
+           method when executed. Raises a ValueError if the instance does
+           not have a method with the specified name.
+        """
+        self._testMethodName = methodName
+        self._outcomeForDoCleanups = None
+        self._testMethodDoc = 'No test'
+        try:
+            testMethod = getattr(self, methodName)
+        except AttributeError:
+            if methodName != 'runTest':
+                # we allow instantiation with no explicit method name
+                # but not an *incorrect* or missing method name
+                raise ValueError("no such test method in %s: %s" %
+                      (self.__class__, methodName))
+        else:
+            self._testMethodDoc = testMethod.__doc__
+        self._cleanups = []
+
+        # Map types to custom assertEqual functions that will compare
+        # instances of said type in more detail to generate a more useful
+        # error message.
+        self._type_equality_funcs = _TypeEqualityDict(self)
+        self.addTypeEqualityFunc(dict, 'assertDictEqual')
+        self.addTypeEqualityFunc(list, 'assertListEqual')
+        self.addTypeEqualityFunc(tuple, 'assertTupleEqual')
+        self.addTypeEqualityFunc(set, 'assertSetEqual')
+        self.addTypeEqualityFunc(frozenset, 'assertSetEqual')
+        self.addTypeEqualityFunc(str, 'assertMultiLineEqual')
+
+    def addTypeEqualityFunc(self, typeobj, function):
+        """Add a type specific assertEqual style function to compare a type.
+
+        This method is for use by TestCase subclasses that need to register
+        their own type equality functions to provide nicer error messages.
+
+        Args:
+            typeobj: The data type to call this function on when both values
+                    are of the same type in assertEqual().
+            function: The callable taking two arguments and an optional
+                    msg= argument that raises self.failureException with a
+                    useful error message when the two arguments are not equal.
+        """
+        self._type_equality_funcs[typeobj] = function
+
+    def addCleanup(self, function, *args, **kwargs):
+        """Add a function, with arguments, to be called when the test is
+        completed. Functions added are called on a LIFO basis and are
+        called after tearDown on test failure or success.
+
+        Cleanup items are called even if setUp fails (unlike tearDown)."""
+        self._cleanups.append((function, args, kwargs))
+
+    def setUp(self):
+        "Hook method for setting up the test fixture before exercising it."
+        pass
+
+    def tearDown(self):
+        "Hook method for deconstructing the test fixture after testing it."
+        pass
+
+    @classmethod
+    def setUpClass(cls):
+        "Hook method for setting up class fixture before running tests in the class."
+
+    @classmethod
+    def tearDownClass(cls):
+        "Hook method for deconstructing the class fixture after running all tests in the class."
+
+    def countTestCases(self):
+        return 1
+
+    def defaultTestResult(self):
+        return result.TestResult()
+
+    def shortDescription(self):
+        """Returns a one-line description of the test, or None if no
+        description has been provided.
+
+        The default implementation of this method returns the first line of
+        the specified test method's docstring.
+        """
+        doc = self._testMethodDoc
+        return doc and doc.split("\n")[0].strip() or None
+
+
+    def id(self):
+        return "%s.%s" % (strclass(self.__class__), self._testMethodName)
+
+    def __eq__(self, other):
+        if type(self) is not type(other):
+            return NotImplemented
+
+        return self._testMethodName == other._testMethodName
+
+    def __hash__(self):
+        return hash((type(self), self._testMethodName))
+
+    def __str__(self):
+        return "%s (%s)" % (self._testMethodName, strclass(self.__class__))
+
+    def __repr__(self):
+        return "<%s testMethod=%s>" % \
+               (strclass(self.__class__), self._testMethodName)
+
+    def _addSkip(self, result, reason):
+        addSkip = getattr(result, 'addSkip', None)
+        if addSkip is not None:
+            addSkip(self, reason)
+        else:
+            warnings.warn("TestResult has no addSkip method, skips not reported",
+                          RuntimeWarning, 2)
+            result.addSuccess(self)
+
+    def _executeTestPart(self, function, outcome, isTest=False):
+        try:
+            function()
+        except KeyboardInterrupt:
+            raise
+        except SkipTest as e:
+            outcome.success = False
+            outcome.skipped = str(e)
+        except _UnexpectedSuccess:
+            exc_info = sys.exc_info()
+            outcome.success = False
+            if isTest:
+                outcome.unexpectedSuccess = exc_info
+            else:
+                outcome.errors.append(exc_info)
+        except _ExpectedFailure:
+            outcome.success = False
+            exc_info = sys.exc_info()
+            if isTest:
+                outcome.expectedFailure = exc_info
+            else:
+                outcome.errors.append(exc_info)
+        except self.failureException:
+            outcome.success = False
+            outcome.failures.append(sys.exc_info())
+            exc_info = sys.exc_info()
+        except:
+            outcome.success = False
+            outcome.errors.append(sys.exc_info())
+
+    def run(self, result=None):
+        orig_result = result
+        if result is None:
+            result = self.defaultTestResult()
+            startTestRun = getattr(result, 'startTestRun', None)
+            if startTestRun is not None:
+                startTestRun()
+
+        result.startTest(self)
+
+        testMethod = getattr(self, self._testMethodName)
+        if (getattr(self.__class__, "__unittest_skip__", False) or
+            getattr(testMethod, "__unittest_skip__", False)):
+            # If the class or method was skipped.
+            try:
+                skip_why = (getattr(self.__class__, '__unittest_skip_why__', '')
+                            or getattr(testMethod, '__unittest_skip_why__', ''))
+                self._addSkip(result, skip_why)
+            finally:
+                result.stopTest(self)
+            return
+        try:
+            outcome = _Outcome()
+            self._outcomeForDoCleanups = outcome
+
+            self._executeTestPart(self.setUp, outcome)
+            if outcome.success:
+                self._executeTestPart(testMethod, outcome, isTest=True)
+                self._executeTestPart(self.tearDown, outcome)
+
+            self.doCleanups()
+            if outcome.success:
+                result.addSuccess(self)
+            else:
+                if outcome.skipped is not None:
+                    self._addSkip(result, outcome.skipped)
+                for exc_info in outcome.errors:
+                    result.addError(self, exc_info)
+                for exc_info in outcome.failures:
+                    result.addFailure(self, exc_info)
+                if outcome.unexpectedSuccess is not None:
+                    addUnexpectedSuccess = getattr(result, 'addUnexpectedSuccess', None)
+                    if addUnexpectedSuccess is not None:
+                        addUnexpectedSuccess(self)
+                    else:
+                        warnings.warn("TestResult has no addUnexpectedSuccess method, reporting as failures",
+                                      RuntimeWarning)
+                        result.addFailure(self, outcome.unexpectedSuccess)
+
+                if outcome.expectedFailure is not None:
+                    addExpectedFailure = getattr(result, 'addExpectedFailure', None)
+                    if addExpectedFailure is not None:
+                        addExpectedFailure(self, outcome.expectedFailure)
+                    else:
+                        warnings.warn("TestResult has no addExpectedFailure method, reporting as passes",
+                                      RuntimeWarning)
+                        result.addSuccess(self)
+            return result
+        finally:
+            result.stopTest(self)
+            if orig_result is None:
+                stopTestRun = getattr(result, 'stopTestRun', None)
+                if stopTestRun is not None:
+                    stopTestRun()
+
+    def doCleanups(self):
+        """Execute all cleanup functions. Normally called for you after
+        tearDown."""
+        outcome = self._outcomeForDoCleanups or _Outcome()
+        while self._cleanups:
+            function, args, kwargs = self._cleanups.pop()
+            part = lambda: function(*args, **kwargs)
+            self._executeTestPart(part, outcome)
+
+        # return this for backwards compatibility
+        # even though we no longer us it internally
+        return outcome.success
+
+    def __call__(self, *args, **kwds):
+        return self.run(*args, **kwds)
+
+    def debug(self):
+        """Run the test without collecting errors in a TestResult"""
+        self.setUp()
+        getattr(self, self._testMethodName)()
+        self.tearDown()
+        while self._cleanups:
+            function, args, kwargs = self._cleanups.pop(-1)
+            function(*args, **kwargs)
+
+    def skipTest(self, reason):
+        """Skip this test."""
+        raise SkipTest(reason)
+
+    def fail(self, msg=None):
+        """Fail immediately, with the given message."""
+        raise self.failureException(msg)
+
+    def assertFalse(self, expr, msg=None):
+        """Check that the expression is false."""
+        if expr:
+            msg = self._formatMessage(msg, "%s is not false" % safe_repr(expr))
+            raise self.failureException(msg)
+
+    def assertTrue(self, expr, msg=None):
+        """Check that the expression is true."""
+        if not expr:
+            msg = self._formatMessage(msg, "%s is not true" % safe_repr(expr))
+            raise self.failureException(msg)
+
+    def _formatMessage(self, msg, standardMsg):
+        """Honour the longMessage attribute when generating failure messages.
+        If longMessage is False this means:
+        * Use only an explicit message if it is provided
+        * Otherwise use the standard message for the assert
+
+        If longMessage is True:
+        * Use the standard message
+        * If an explicit message is provided, plus ' : ' and the explicit message
+        """
+        if not self.longMessage:
+            return msg or standardMsg
+        if msg is None:
+            return standardMsg
+        try:
+            # don't switch to '{}' formatting in Python 2.X
+            # it changes the way unicode input is handled
+            return '%s : %s' % (standardMsg, msg)
+        except UnicodeDecodeError:
+            return  '%s : %s' % (safe_repr(standardMsg), safe_repr(msg))
+
+
+    def assertRaises(self, excClass, callableObj=None, *args, **kwargs):
+        """Fail unless an exception of class excClass is thrown
+           by callableObj when invoked with arguments args and keyword
+           arguments kwargs. If a different type of exception is
+           thrown, it will not be caught, and the test case will be
+           deemed to have suffered an error, exactly as for an
+           unexpected exception.
+
+           If called with callableObj omitted or None, will return a
+           context object used like this::
+
+                with self.assertRaises(SomeException):
+                    do_something()
+
+           The context manager keeps a reference to the exception as
+           the 'exception' attribute. This allows you to inspect the
+           exception after the assertion::
+
+               with self.assertRaises(SomeException) as cm:
+                   do_something()
+               the_exception = cm.exception
+               self.assertEqual(the_exception.error_code, 3)
+        """
+        context = _AssertRaisesContext(excClass, self, callableObj)
+        if callableObj is None:
+            return context
+        with context:
+            callableObj(*args, **kwargs)
+
+    def assertWarns(self, expected_warning, callable_obj=None, *args, **kwargs):
+        """Fail unless a warning of class warnClass is triggered
+           by callableObj when invoked with arguments args and keyword
+           arguments kwargs.  If a different type of warning is
+           triggered, it will not be handled: depending on the other
+           warning filtering rules in effect, it might be silenced, printed
+           out, or raised as an exception.
+
+           If called with callableObj omitted or None, will return a
+           context object used like this::
+
+                with self.assertWarns(SomeWarning):
+                    do_something()
+
+           The context manager keeps a reference to the first matching
+           warning as the 'warning' attribute; similarly, the 'filename'
+           and 'lineno' attributes give you information about the line
+           of Python code from which the warning was triggered.
+           This allows you to inspect the warning after the assertion::
+
+               with self.assertWarns(SomeWarning) as cm:
+                   do_something()
+               the_warning = cm.warning
+               self.assertEqual(the_warning.some_attribute, 147)
+        """
+        context = _AssertWarnsContext(expected_warning, self, callable_obj)
+        if callable_obj is None:
+            return context
+        with context:
+            callable_obj(*args, **kwargs)
+
+    def _getAssertEqualityFunc(self, first, second):
+        """Get a detailed comparison function for the types of the two args.
+
+        Returns: A callable accepting (first, second, msg=None) that will
+        raise a failure exception if first != second with a useful human
+        readable error message for those types.
+        """
+        #
+        # NOTE(gregory.p.smith): I considered isinstance(first, type(second))
+        # and vice versa.  I opted for the conservative approach in case
+        # subclasses are not intended to be compared in detail to their super
+        # class instances using a type equality func.  This means testing
+        # subtypes won't automagically use the detailed comparison.  Callers
+        # should use their type specific assertSpamEqual method to compare
+        # subclasses if the detailed comparison is desired and appropriate.
+        # See the discussion in http://bugs.python.org/issue2578.
+        #
+        if type(first) is type(second):
+            asserter = self._type_equality_funcs.get(type(first))
+            if asserter is not None:
+                return asserter
+
+        return self._baseAssertEqual
+
+    def _baseAssertEqual(self, first, second, msg=None):
+        """The default assertEqual implementation, not type specific."""
+        if not first == second:
+            standardMsg = '%s != %s' % (safe_repr(first), safe_repr(second))
+            msg = self._formatMessage(msg, standardMsg)
+            raise self.failureException(msg)
+
+    def assertEqual(self, first, second, msg=None):
+        """Fail if the two objects are unequal as determined by the '=='
+           operator.
+        """
+        assertion_func = self._getAssertEqualityFunc(first, second)
+        assertion_func(first, second, msg=msg)
+
+    def assertNotEqual(self, first, second, msg=None):
+        """Fail if the two objects are equal as determined by the '=='
+           operator.
+        """
+        if not first != second:
+            msg = self._formatMessage(msg, '%s == %s' % (safe_repr(first),
+                                                          safe_repr(second)))
+            raise self.failureException(msg)
+
+    def assertAlmostEqual(self, first, second, places=None, msg=None,
+                          delta=None):
+        """Fail if the two objects are unequal as determined by their
+           difference rounded to the given number of decimal places
+           (default 7) and comparing to zero, or by comparing that the
+           between the two objects is more than the given delta.
+
+           Note that decimal places (from zero) are usually not the same
+           as significant digits (measured from the most signficant digit).
+
+           If the two objects compare equal then they will automatically
+           compare almost equal.
+        """
+        if first == second:
+            # shortcut
+            return
+        if delta is not None and places is not None:
+            raise TypeError("specify delta or places not both")
+
+        if delta is not None:
+            if abs(first - second) <= delta:
+                return
+
+            standardMsg = '%s != %s within %s delta' % (safe_repr(first),
+                                                        safe_repr(second),
+                                                        safe_repr(delta))
+        else:
+            if places is None:
+                places = 7
+
+            if round(abs(second-first), places) == 0:
+                return
+
+            standardMsg = '%s != %s within %r places' % (safe_repr(first),
+                                                          safe_repr(second),
+                                                          places)
+        msg = self._formatMessage(msg, standardMsg)
+        raise self.failureException(msg)
+
+    def assertNotAlmostEqual(self, first, second, places=None, msg=None,
+                             delta=None):
+        """Fail if the two objects are equal as determined by their
+           difference rounded to the given number of decimal places
+           (default 7) and comparing to zero, or by comparing that the
+           between the two objects is less than the given delta.
+
+           Note that decimal places (from zero) are usually not the same
+           as significant digits (measured from the most signficant digit).
+
+           Objects that are equal automatically fail.
+        """
+        if delta is not None and places is not None:
+            raise TypeError("specify delta or places not both")
+        if delta is not None:
+            if not (first == second) and abs(first - second) > delta:
+                return
+            standardMsg = '%s == %s within %s delta' % (safe_repr(first),
+                                                        safe_repr(second),
+                                                        safe_repr(delta))
+        else:
+            if places is None:
+                places = 7
+            if not (first == second) and round(abs(second-first), places) != 0:
+                return
+            standardMsg = '%s == %s within %r places' % (safe_repr(first),
+                                                         safe_repr(second),
+                                                         places)
+
+        msg = self._formatMessage(msg, standardMsg)
+        raise self.failureException(msg)
+
+
+    def assertSequenceEqual(self, seq1, seq2, msg=None, seq_type=None):
+        """An equality assertion for ordered sequences (like lists and tuples).
+
+        For the purposes of this function, a valid ordered sequence type is one
+        which can be indexed, has a length, and has an equality operator.
+
+        Args:
+            seq1: The first sequence to compare.
+            seq2: The second sequence to compare.
+            seq_type: The expected datatype of the sequences, or None if no
+                    datatype should be enforced.
+            msg: Optional message to use on failure instead of a list of
+                    differences.
+        """
+        if seq_type != None:
+            seq_type_name = seq_type.__name__
+            if not isinstance(seq1, seq_type):
+                raise self.failureException('First sequence is not a %s: %s'
+                                        % (seq_type_name, safe_repr(seq1)))
+            if not isinstance(seq2, seq_type):
+                raise self.failureException('Second sequence is not a %s: %s'
+                                        % (seq_type_name, safe_repr(seq2)))
+        else:
+            seq_type_name = "sequence"
+
+        differing = None
+        try:
+            len1 = len(seq1)
+        except (TypeError, NotImplementedError):
+            differing = 'First %s has no length.    Non-sequence?' % (
+                    seq_type_name)
+
+        if differing is None:
+            try:
+                len2 = len(seq2)
+            except (TypeError, NotImplementedError):
+                differing = 'Second %s has no length.    Non-sequence?' % (
+                        seq_type_name)
+
+        if differing is None:
+            if seq1 == seq2:
+                return
+
+            seq1_repr = safe_repr(seq1)
+            seq2_repr = safe_repr(seq2)
+            if len(seq1_repr) > 30:
+                seq1_repr = seq1_repr[:30] + '...'
+            if len(seq2_repr) > 30:
+                seq2_repr = seq2_repr[:30] + '...'
+            elements = (seq_type_name.capitalize(), seq1_repr, seq2_repr)
+            differing = '%ss differ: %s != %s\n' % elements
+
+            for i in range(min(len1, len2)):
+                try:
+                    item1 = seq1[i]
+                except (TypeError, IndexError, NotImplementedError):
+                    differing += ('\nUnable to index element %d of first %s\n' %
+                                 (i, seq_type_name))
+                    break
+
+                try:
+                    item2 = seq2[i]
+                except (TypeError, IndexError, NotImplementedError):
+                    differing += ('\nUnable to index element %d of second %s\n' %
+                                 (i, seq_type_name))
+                    break
+
+                if item1 != item2:
+                    differing += ('\nFirst differing element %d:\n%s\n%s\n' %
+                                 (i, item1, item2))
+                    break
+            else:
+                if (len1 == len2 and seq_type is None and
+                    type(seq1) != type(seq2)):
+                    # The sequences are the same, but have differing types.
+                    return
+
+            if len1 > len2:
+                differing += ('\nFirst %s contains %d additional '
+                             'elements.\n' % (seq_type_name, len1 - len2))
+                try:
+                    differing += ('First extra element %d:\n%s\n' %
+                                  (len2, seq1[len2]))
+                except (TypeError, IndexError, NotImplementedError):
+                    differing += ('Unable to index element %d '
+                                  'of first %s\n' % (len2, seq_type_name))
+            elif len1 < len2:
+                differing += ('\nSecond %s contains %d additional '
+                             'elements.\n' % (seq_type_name, len2 - len1))
+                try:
+                    differing += ('First extra element %d:\n%s\n' %
+                                  (len1, seq2[len1]))
+                except (TypeError, IndexError, NotImplementedError):
+                    differing += ('Unable to index element %d '
+                                  'of second %s\n' % (len1, seq_type_name))
+        standardMsg = differing
+        diffMsg = '\n' + '\n'.join(
+            difflib.ndiff(pprint.pformat(seq1).splitlines(),
+                          pprint.pformat(seq2).splitlines()))
+
+        standardMsg = self._truncateMessage(standardMsg, diffMsg)
+        msg = self._formatMessage(msg, standardMsg)
+        self.fail(msg)
+
+    def _truncateMessage(self, message, diff):
+        max_diff = self.maxDiff
+        if max_diff is None or len(diff) <= max_diff:
+            return message + diff
+        return message + (DIFF_OMITTED % len(diff))
+
+    def assertListEqual(self, list1, list2, msg=None):
+        """A list-specific equality assertion.
+
+        Args:
+            list1: The first list to compare.
+            list2: The second list to compare.
+            msg: Optional message to use on failure instead of a list of
+                    differences.
+
+        """
+        self.assertSequenceEqual(list1, list2, msg, seq_type=list)
+
+    def assertTupleEqual(self, tuple1, tuple2, msg=None):
+        """A tuple-specific equality assertion.
+
+        Args:
+            tuple1: The first tuple to compare.
+            tuple2: The second tuple to compare.
+            msg: Optional message to use on failure instead of a list of
+                    differences.
+        """
+        self.assertSequenceEqual(tuple1, tuple2, msg, seq_type=tuple)
+
+    def assertSetEqual(self, set1, set2, msg=None):
+        """A set-specific equality assertion.
+
+        Args:
+            set1: The first set to compare.
+            set2: The second set to compare.
+            msg: Optional message to use on failure instead of a list of
+                    differences.
+
+        assertSetEqual uses ducktyping to support different types of sets, and
+        is optimized for sets specifically (parameters must support a
+        difference method).
+        """
+        try:
+            difference1 = set1.difference(set2)
+        except TypeError as e:
+            self.fail('invalid type when attempting set difference: %s' % e)
+        except AttributeError as e:
+            self.fail('first argument does not support set difference: %s' % e)
+
+        try:
+            difference2 = set2.difference(set1)
+        except TypeError as e:
+            self.fail('invalid type when attempting set difference: %s' % e)
+        except AttributeError as e:
+            self.fail('second argument does not support set difference: %s' % e)
+
+        if not (difference1 or difference2):
+            return
+
+        lines = []
+        if difference1:
+            lines.append('Items in the first set but not the second:')
+            for item in difference1:
+                lines.append(repr(item))
+        if difference2:
+            lines.append('Items in the second set but not the first:')
+            for item in difference2:
+                lines.append(repr(item))
+
+        standardMsg = '\n'.join(lines)
+        self.fail(self._formatMessage(msg, standardMsg))
+
+    def assertIn(self, member, container, msg=None):
+        """Just like self.assertTrue(a in b), but with a nicer default message."""
+        if member not in container:
+            standardMsg = '%s not found in %s' % (safe_repr(member),
+                                                  safe_repr(container))
+            self.fail(self._formatMessage(msg, standardMsg))
+
+    def assertNotIn(self, member, container, msg=None):
+        """Just like self.assertTrue(a not in b), but with a nicer default message."""
+        if member in container:
+            standardMsg = '%s unexpectedly found in %s' % (safe_repr(member),
+                                                        safe_repr(container))
+            self.fail(self._formatMessage(msg, standardMsg))
+
+    def assertIs(self, expr1, expr2, msg=None):
+        """Just like self.assertTrue(a is b), but with a nicer default message."""
+        if expr1 is not expr2:
+            standardMsg = '%s is not %s' % (safe_repr(expr1),
+                                             safe_repr(expr2))
+            self.fail(self._formatMessage(msg, standardMsg))
+
+    def assertIsNot(self, expr1, expr2, msg=None):
+        """Just like self.assertTrue(a is not b), but with a nicer default message."""
+        if expr1 is expr2:
+            standardMsg = 'unexpectedly identical: %s' % (safe_repr(expr1),)
+            self.fail(self._formatMessage(msg, standardMsg))
+
+    def assertDictEqual(self, d1, d2, msg=None):
+        self.assertIsInstance(d1, dict, 'First argument is not a dictionary')
+        self.assertIsInstance(d2, dict, 'Second argument is not a dictionary')
+
+        if d1 != d2:
+            standardMsg = '%s != %s' % (safe_repr(d1, True), safe_repr(d2, True))
+            diff = ('\n' + '\n'.join(difflib.ndiff(
+                           pprint.pformat(d1).splitlines(),
+                           pprint.pformat(d2).splitlines())))
+            standardMsg = self._truncateMessage(standardMsg, diff)
+            self.fail(self._formatMessage(msg, standardMsg))
+
+    def assertCountEqual(self, first, second, msg=None):
+        """An unordered sequence comparison asserting that the same elements,
+        regardless of order.  If the same element occurs more than once,
+        it verifies that the elements occur the same number of times.
+
+            self.assertEqual(Counter(list(first)),
+                             Counter(list(second)))
+
+         Example:
+            - [0, 1, 1] and [1, 0, 1] compare equal.
+            - [0, 0, 1] and [0, 1] compare unequal.
+
+        """
+        first_seq, second_seq = list(first), list(second)
+        try:
+            first = collections.Counter(first_seq)
+            second = collections.Counter(second_seq)
+        except TypeError:
+            # Handle case with unhashable elements
+            differences = _count_diff_all_purpose(first_seq, second_seq)
+        else:
+            if first == second:
+                return
+            differences = _count_diff_hashable(first_seq, second_seq)
+
+        if differences:
+            standardMsg = 'Element counts were not equal:\n'
+            lines = ['First has %d, Second has %d:  %r' % diff for diff in differences]
+            diffMsg = '\n'.join(lines)
+            standardMsg = self._truncateMessage(standardMsg, diffMsg)
+            msg = self._formatMessage(msg, standardMsg)
+            self.fail(msg)
+
+    def assertMultiLineEqual(self, first, second, msg=None):
+        """Assert that two multi-line strings are equal."""
+        self.assertIsInstance(first, str, 'First argument is not a string')
+        self.assertIsInstance(second, str, 'Second argument is not a string')
+
+        if first != second:
+            firstlines = first.splitlines(True)
+            secondlines = second.splitlines(True)
+            if len(firstlines) == 1 and first.strip('\r\n') == first:
+                firstlines = [first + '\n']
+                secondlines = [second + '\n']
+            standardMsg = '%s != %s' % (safe_repr(first, True),
+                                        safe_repr(second, True))
+            diff = '\n' + ''.join(difflib.ndiff(firstlines, secondlines))
+            standardMsg = self._truncateMessage(standardMsg, diff)
+            self.fail(self._formatMessage(msg, standardMsg))
+
+    def assertLess(self, a, b, msg=None):
+        """Just like self.assertTrue(a < b), but with a nicer default message."""
+        if not a < b:
+            standardMsg = '%s not less than %s' % (safe_repr(a), safe_repr(b))
+            self.fail(self._formatMessage(msg, standardMsg))
+
+    def assertLessEqual(self, a, b, msg=None):
+        """Just like self.assertTrue(a <= b), but with a nicer default message."""
+        if not a <= b:
+            standardMsg = '%s not less than or equal to %s' % (safe_repr(a), safe_repr(b))
+            self.fail(self._formatMessage(msg, standardMsg))
+
+    def assertGreater(self, a, b, msg=None):
+        """Just like self.assertTrue(a > b), but with a nicer default message."""
+        if not a > b:
+            standardMsg = '%s not greater than %s' % (safe_repr(a), safe_repr(b))
+            self.fail(self._formatMessage(msg, standardMsg))
+
+    def assertGreaterEqual(self, a, b, msg=None):
+        """Just like self.assertTrue(a >= b), but with a nicer default message."""
+        if not a >= b:
+            standardMsg = '%s not greater than or equal to %s' % (safe_repr(a), safe_repr(b))
+            self.fail(self._formatMessage(msg, standardMsg))
+
+    def assertIsNone(self, obj, msg=None):
+        """Same as self.assertTrue(obj is None), with a nicer default message."""
+        if obj is not None:
+            standardMsg = '%s is not None' % (safe_repr(obj),)
+            self.fail(self._formatMessage(msg, standardMsg))
+
+    def assertIsNotNone(self, obj, msg=None):
+        """Included for symmetry with assertIsNone."""
+        if obj is None:
+            standardMsg = 'unexpectedly None'
+            self.fail(self._formatMessage(msg, standardMsg))
+
+    def assertIsInstance(self, obj, cls, msg=None):
+        """Same as self.assertTrue(isinstance(obj, cls)), with a nicer
+        default message."""
+        if not isinstance(obj, cls):
+            standardMsg = '%s is not an instance of %r' % (safe_repr(obj), cls)
+            self.fail(self._formatMessage(msg, standardMsg))
+
+    def assertNotIsInstance(self, obj, cls, msg=None):
+        """Included for symmetry with assertIsInstance."""
+        if isinstance(obj, cls):
+            standardMsg = '%s is an instance of %r' % (safe_repr(obj), cls)
+            self.fail(self._formatMessage(msg, standardMsg))
+
+    def assertRaisesRegex(self, expected_exception, expected_regex,
+                          callable_obj=None, *args, **kwargs):
+        """Asserts that the message in a raised exception matches a regex.
+
+        Args:
+            expected_exception: Exception class expected to be raised.
+            expected_regex: Regex (re pattern object or string) expected
+                    to be found in error message.
+            callable_obj: Function to be called.
+            args: Extra args.
+            kwargs: Extra kwargs.
+        """
+        context = _AssertRaisesContext(expected_exception, self, callable_obj,
+                                       expected_regex)
+        if callable_obj is None:
+            return context
+        with context:
+            callable_obj(*args, **kwargs)
+
+    def assertWarnsRegex(self, expected_warning, expected_regex,
+                         callable_obj=None, *args, **kwargs):
+        """Asserts that the message in a triggered warning matches a regexp.
+        Basic functioning is similar to assertWarns() with the addition
+        that only warnings whose messages also match the regular expression
+        are considered successful matches.
+
+        Args:
+            expected_warning: Warning class expected to be triggered.
+            expected_regex: Regex (re pattern object or string) expected
+                    to be found in error message.
+            callable_obj: Function to be called.
+            args: Extra args.
+            kwargs: Extra kwargs.
+        """
+        context = _AssertWarnsContext(expected_warning, self, callable_obj,
+                                      expected_regex)
+        if callable_obj is None:
+            return context
+        with context:
+            callable_obj(*args, **kwargs)
+
+    def assertRegex(self, text, expected_regex, msg=None):
+        """Fail the test unless the text matches the regular expression."""
+        if isinstance(expected_regex, (str, bytes)):
+            assert expected_regex, "expected_regex must not be empty."
+            expected_regex = re.compile(expected_regex)
+        if not expected_regex.search(text):
+            msg = msg or "Regex didn't match"
+            msg = '%s: %r not found in %r' % (msg, expected_regex.pattern, text)
+            raise self.failureException(msg)
+
+    def assertNotRegex(self, text, unexpected_regex, msg=None):
+        """Fail the test if the text matches the regular expression."""
+        if isinstance(unexpected_regex, (str, bytes)):
+            unexpected_regex = re.compile(unexpected_regex)
+        match = unexpected_regex.search(text)
+        if match:
+            msg = msg or "Regex matched"
+            msg = '%s: %r matches %r in %r' % (msg,
+                                               text[match.start():match.end()],
+                                               unexpected_regex.pattern,
+                                               text)
+            raise self.failureException(msg)
+
+
+    def _deprecate(original_func):
+        def deprecated_func(*args, **kwargs):
+            warnings.warn(
+                'Please use {0} instead.'.format(original_func.__name__),
+                DeprecationWarning, 2)
+            return original_func(*args, **kwargs)
+        return deprecated_func
+
+    # The fail* methods can be removed in 3.3, the 5 assert* methods will
+    # have to stay around for a few more versions.  See #9424.
+    assertEquals = _deprecate(assertEqual)
+    assertNotEquals = _deprecate(assertNotEqual)
+    assertAlmostEquals = _deprecate(assertAlmostEqual)
+    assertNotAlmostEquals = _deprecate(assertNotAlmostEqual)
+    assert_ = _deprecate(assertTrue)
+    assertRaisesRegexp = _deprecate(assertRaisesRegex)
+    assertRegexpMatches = _deprecate(assertRegex)
+
+
+
+class FunctionTestCase(TestCase):
+    """A test case that wraps a test function.
+
+    This is useful for slipping pre-existing test functions into the
+    unittest framework. Optionally, set-up and tidy-up functions can be
+    supplied. As with TestCase, the tidy-up ('tearDown') function will
+    always be called if the set-up ('setUp') function ran successfully.
+    """
+
+    def __init__(self, testFunc, setUp=None, tearDown=None, description=None):
+        super(FunctionTestCase, self).__init__()
+        self._setUpFunc = setUp
+        self._tearDownFunc = tearDown
+        self._testFunc = testFunc
+        self._description = description
+
+    def setUp(self):
+        if self._setUpFunc is not None:
+            self._setUpFunc()
+
+    def tearDown(self):
+        if self._tearDownFunc is not None:
+            self._tearDownFunc()
+
+    def runTest(self):
+        self._testFunc()
+
+    def id(self):
+        return self._testFunc.__name__
+
+    def __eq__(self, other):
+        if not isinstance(other, self.__class__):
+            return NotImplemented
+
+        return self._setUpFunc == other._setUpFunc and \
+               self._tearDownFunc == other._tearDownFunc and \
+               self._testFunc == other._testFunc and \
+               self._description == other._description
+
+    def __ne__(self, other):
+        return not self == other
+
+    def __hash__(self):
+        return hash((type(self), self._setUpFunc, self._tearDownFunc,
+                     self._testFunc, self._description))
+
+    def __str__(self):
+        return "%s (%s)" % (strclass(self.__class__),
+                            self._testFunc.__name__)
+
+    def __repr__(self):
+        return "<%s tec=%s>" % (strclass(self.__class__),
+                                     self._testFunc)
+
+    def shortDescription(self):
+        if self._description is not None:
+            return self._description
+        doc = self._testFunc.__doc__
+        return doc and doc.split("\n")[0].strip() or None
diff -u -x '*.pyc' --recursive --new-file cpython/Lib/unittest/compatibility.py unittest2/compatibility.py
--- cpython/Lib/unittest/compatibility.py	1969-12-31 19:00:00.000000000 -0500
+++ unittest2/compatibility.py	2011-03-25 21:38:23.000000000 -0400
@@ -0,0 +1,321 @@
+try:
+    from functools import cmp_to_key
+except ImportError:
+    # Python 3.0 / 3.1
+    def cmp_to_key(mycmp):
+        """Convert a cmp= function into a key= function"""
+        class K(object):
+            def __init__(self, obj, *args):
+                self.obj = obj
+            def __lt__(self, other):
+                return mycmp(self.obj, other.obj) < 0
+            def __gt__(self, other):
+                return mycmp(self.obj, other.obj) > 0
+            def __eq__(self, other):
+                return mycmp(self.obj, other.obj) == 0
+            def __le__(self, other):
+                return mycmp(self.obj, other.obj) <= 0
+            def __ge__(self, other):
+                return mycmp(self.obj, other.obj) >= 0
+            def __ne__(self, other):
+                return mycmp(self.obj, other.obj) != 0
+            def __hash__(self):
+                raise TypeError('hash not implemented')
+        return K
+
+try:
+    from collections import OrderedDict, Counter
+except ImportError:
+    # Python 3.0
+
+    # OrderedDict taken from http://pypi.python.org/pypi/ordereddict/
+    class OrderedDict(dict):
+
+        def __init__(self, *args, **kwds):
+            if len(args) > 1:
+                raise TypeError('expected at most 1 arguments, got %d' % len(args))
+            try:
+                self.__end
+            except AttributeError:
+                self.clear()
+            self.update(*args, **kwds)
+
+        def clear(self):
+            self.__end = end = []
+            end += [None, end, end]         # sentinel node for doubly linked list
+            self.__map = {}                 # key --> [key, prev, next]
+            dict.clear(self)
+
+        def __setitem__(self, key, value):
+            if key not in self:
+                end = self.__end
+                curr = end[1]
+                curr[2] = end[1] = self.__map[key] = [key, curr, end]
+            dict.__setitem__(self, key, value)
+
+        def __delitem__(self, key):
+            dict.__delitem__(self, key)
+            key, prev, next = self.__map.pop(key)
+            prev[2] = next
+            next[1] = prev
+
+        def __iter__(self):
+            end = self.__end
+            curr = end[2]
+            while curr is not end:
+                yield curr[0]
+                curr = curr[2]
+
+        def __reversed__(self):
+            end = self.__end
+            curr = end[1]
+            while curr is not end:
+                yield curr[0]
+                curr = curr[1]
+
+        def popitem(self, last=True):
+            if not self:
+                raise KeyError('dictionary is empty')
+            if last:
+                key = reversed(self).next()
+            else:
+                key = iter(self).next()
+            value = self.pop(key)
+            return key, value
+
+        def __reduce__(self):
+            items = [[k, self[k]] for k in self]
+            tmp = self.__map, self.__end
+            del self.__map, self.__end
+            inst_dict = vars(self).copy()
+            self.__map, self.__end = tmp
+            if inst_dict:
+                return (self.__class__, (items,), inst_dict)
+            return self.__class__, (items,)
+
+        def keys(self):
+            return list(self)
+
+#         setdefault = DictMixin.setdefault
+#         update = DictMixin.update
+#         pop = DictMixin.pop
+#         values = DictMixin.values
+#         items = DictMixin.items
+#         iterkeys = DictMixin.iterkeys
+#         itervalues = DictMixin.itervalues
+#         iteritems = DictMixin.iteritems
+
+        def __repr__(self):
+            if not self:
+                return '%s()' % (self.__class__.__name__,)
+            return '%s(%r)' % (self.__class__.__name__, self.items())
+
+        def copy(self):
+            return self.__class__(self)
+
+        @classmethod
+        def fromkeys(cls, iterable, value=None):
+            d = cls()
+            for key in iterable:
+                d[key] = value
+            return d
+
+        def __eq__(self, other):
+            if isinstance(other, OrderedDict):
+                if len(self) != len(other):
+                    return False
+                for p, q in  zip(self.items(), other.items()):
+                    if p != q:
+                        return False
+                return True
+            return dict.__eq__(self, other)
+
+        def __ne__(self, other):
+            return not self == other
+
+
+    # Taken from Python 3.1
+    class Counter(dict):
+
+        def __init__(self, iterable=None, **kwds):
+            self.update(iterable, **kwds)
+
+        def __missing__(self, key):
+            'The count of elements not in the Counter is zero.'
+            # Needed so that self[missing_item] does not raise KeyError
+            return 0
+
+        def most_common(self, n=None):
+            '''List the n most common elements and their counts from the most
+            common to the least.  If n is None, then list all element counts.
+
+            >>> Counter('abracadabra').most_common(3)
+            [('a', 5), ('r', 2), ('b', 2)]
+
+            '''
+            # Emulate Bag.sortedByCount from Smalltalk
+            if n is None:
+                return sorted(self.items(), key=_itemgetter(1), reverse=True)
+            return _heapq.nlargest(n, self.items(), key=_itemgetter(1))
+
+        def elements(self):
+            '''Iterator over elements repeating each as many times as its count.
+
+            >>> c = Counter('ABCABC')
+            >>> sorted(c.elements())
+            ['A', 'A', 'B', 'B', 'C', 'C']
+
+            # Knuth's example for prime factors of 1836:  2**2 * 3**3 * 17**1
+            >>> prime_factors = Counter({2: 2, 3: 3, 17: 1})
+            >>> product = 1
+            >>> for factor in prime_factors.elements():     # loop over factors
+            ...     product *= factor                       # and multiply them
+            >>> product
+            1836
+
+            Note, if an element's count has been set to zero or is a negative
+            number, elements() will ignore it.
+
+            '''
+            # Emulate Bag.do from Smalltalk and Multiset.begin from C++.
+            return _chain.from_iterable(_starmap(_repeat, self.items()))
+
+        # Override dict methods where necessary
+
+        @classmethod
+        def fromkeys(cls, iterable, v=None):
+            # There is no equivalent method for counters because setting v=1
+            # means that no element can have a count greater than one.
+            raise NotImplementedError(
+                'Counter.fromkeys() is undefined.  Use Counter(iterable) instead.')
+
+        def update(self, iterable=None, **kwds):
+            '''Like dict.update() but add counts instead of replacing them.
+
+            Source can be an iterable, a dictionary, or another Counter instance.
+
+            >>> c = Counter('which')
+            >>> c.update('witch')           # add elements from another iterable
+            >>> d = Counter('watch')
+            >>> c.update(d)                 # add elements from another counter
+            >>> c['h']                      # four 'h' in which, witch, and watch
+            4
+
+            '''
+            # The regular dict.update() operation makes no sense here because the
+            # replace behavior results in the some of original untouched counts
+            # being mixed-in with all of the other counts for a mismash that
+            # doesn't have a straight-forward interpretation in most counting
+            # contexts.  Instead, we implement straight-addition.  Both the inputs
+            # and outputs are allowed to contain zero and negative counts.
+
+            if iterable is not None:
+
+                # No 'Mapping' in Python 3.0 so using straight
+                # dict for type checking.  This is satisfactory
+                # for our limited use case
+                if isinstance(iterable, dict):
+                    if self:
+                        self_get = self.get
+                        for elem, count in iterable.items():
+                            self[elem] = count + self_get(elem, 0)
+                    else:
+                        dict.update(self, iterable) # fast path when counter is empty
+                else:
+                    self_get = self.get
+                    for elem in iterable:
+                        self[elem] = 1 + self_get(elem, 0)
+            if kwds:
+                self.update(kwds)
+
+        def copy(self):
+            'Like dict.copy() but returns a Counter instance instead of a dict.'
+            return Counter(self)
+
+        def __delitem__(self, elem):
+            'Like dict.__delitem__() but does not raise KeyError for missing values.'
+            if elem in self:
+                dict.__delitem__(self, elem)
+
+        def __repr__(self):
+            if not self:
+                return '%s()' % self.__class__.__name__
+            items = ', '.join(map('%r: %r'.__mod__, self.most_common()))
+            return '%s({%s})' % (self.__class__.__name__, items)
+
+        # Multiset-style mathematical operations discussed in:
+        #       Knuth TAOCP Volume II section 4.6.3 exercise 19
+        #       and at http://en.wikipedia.org/wiki/Multiset
+        #
+        # Outputs guaranteed to only include positive counts.
+        #
+        # To strip negative and zero counts, add-in an empty counter:
+        #       c += Counter()
+
+        def __add__(self, other):
+            '''Add counts from two counters.
+
+            >>> Counter('abbb') + Counter('bcc')
+            Counter({'b': 4, 'c': 2, 'a': 1})
+
+            '''
+            if not isinstance(other, Counter):
+                return NotImplemented
+            result = Counter()
+            for elem in set(self) | set(other):
+                newcount = self[elem] + other[elem]
+                if newcount > 0:
+                    result[elem] = newcount
+            return result
+
+        def __sub__(self, other):
+            ''' Subtract count, but keep only results with positive counts.
+
+            >>> Counter('abbbc') - Counter('bccd')
+            Counter({'b': 2, 'a': 1})
+
+            '''
+            if not isinstance(other, Counter):
+                return NotImplemented
+            result = Counter()
+            for elem in set(self) | set(other):
+                newcount = self[elem] - other[elem]
+                if newcount > 0:
+                    result[elem] = newcount
+            return result
+
+        def __or__(self, other):
+            '''Union is the maximum of value in either of the input counters.
+
+            >>> Counter('abbb') | Counter('bcc')
+            Counter({'b': 3, 'c': 2, 'a': 1})
+
+            '''
+            if not isinstance(other, Counter):
+                return NotImplemented
+            result = Counter()
+            for elem in set(self) | set(other):
+                p, q = self[elem], other[elem]
+                newcount = q if p < q else p
+                if newcount > 0:
+                    result[elem] = newcount
+            return result
+
+        def __and__(self, other):
+            ''' Intersection is the minimum of corresponding counts.
+
+            >>> Counter('abbb') & Counter('bcc')
+            Counter({'b': 1})
+
+            '''
+            if not isinstance(other, Counter):
+                return NotImplemented
+            result = Counter()
+            if len(self) < len(other):
+                self, other = other, self
+            for elem in filter(self.__contains__, other):
+                p, q = self[elem], other[elem]
+                newcount = p if p < q else q
+                if newcount > 0:
+                    result[elem] = newcount
+            return result
diff -u -x '*.pyc' --recursive --new-file cpython/Lib/unittest/__init__.py unittest2/__init__.py
--- cpython/Lib/unittest/__init__.py	2011-03-24 02:43:51.000000000 -0400
+++ unittest2/__init__.py	2011-03-25 21:38:23.000000000 -0400
@@ -9,9 +9,9 @@
 
 Simple usage:
 
-    import unittest
+    import unittest2
 
-    class IntegerArithmenticTestCase(unittest.TestCase):
+    class IntegerArithmenticTestCase(unittest2.TestCase):
         def testAdd(self):  ## test method names begin 'test*'
             self.assertEqual((1 + 2), 3)
             self.assertEqual(0 + 1, 1)
@@ -20,7 +20,7 @@
             self.assertEqual((5 * 8), 40)
 
     if __name__ == '__main__':
-        unittest.main()
+        unittest2.main()
 
 Further information is available in the bundled documentation, and from
 
@@ -53,6 +53,8 @@
 # Expose obsolete functions for backwards compatibility
 __all__.extend(['getTestCaseNames', 'makeSuite', 'findTestCases'])
 
+__version__ = '0.5.1'
+
 __unittest = True
 
 from .result import TestResult
diff -u -x '*.pyc' --recursive --new-file cpython/Lib/unittest/loader.py unittest2/loader.py
--- cpython/Lib/unittest/loader.py	2011-03-24 02:43:51.000000000 -0400
+++ unittest2/loader.py	2011-03-25 21:38:23.000000000 -0400
@@ -5,11 +5,12 @@
 import sys
 import traceback
 import types
-import functools
+import unittest
 
 from fnmatch import fnmatch
 
 from . import case, suite, util
+from .compatibility import cmp_to_key
 
 __unittest = True
 
@@ -35,7 +36,7 @@
     return suiteClass((TestClass(methodname),))
 
 
-class TestLoader(object):
+class TestLoader(unittest.TestLoader):
     """
     This class is responsible for loading tests according to various criteria
     and returning them wrapped in a TestSuite
@@ -142,7 +143,7 @@
         testFnNames = testFnNames = list(filter(isTestMethod,
                                                 dir(testCaseClass)))
         if self.sortTestMethodsUsing:
-            testFnNames.sort(key=functools.cmp_to_key(self.sortTestMethodsUsing))
+            testFnNames.sort(key=cmp_to_key(self.sortTestMethodsUsing))
         return testFnNames
 
     def discover(self, start_dir, pattern='test*.py', top_level_dir=None):
diff -u -x '*.pyc' --recursive --new-file cpython/Lib/unittest/main.py unittest2/main.py
--- cpython/Lib/unittest/main.py	2011-03-24 02:43:51.000000000 -0400
+++ unittest2/main.py	2011-03-25 21:38:23.000000000 -0400
@@ -3,6 +3,7 @@
 import sys
 import os
 import types
+import unittest
 
 from . import loader, runner
 from .signals import installHandler
@@ -77,7 +78,7 @@
 def _convert_names(names):
     return [_convert_name(name) for name in names]
 
-class TestProgram(object):
+class TestProgram(unittest.TestProgram):
     """A command-line program that runs a set of tests; this is primarily
        for making test modules conveniently executable.
     """
diff -u -x '*.pyc' --recursive --new-file cpython/Lib/unittest/result.py unittest2/result.py
--- cpython/Lib/unittest/result.py	2011-03-24 02:43:51.000000000 -0400
+++ unittest2/result.py	2011-03-25 21:38:23.000000000 -0400
@@ -4,6 +4,7 @@
 import io
 import sys
 import traceback
+import unittest
 
 from . import util
 from functools import wraps
@@ -22,7 +23,7 @@
 STDERR_LINE = '\nStderr:\n%s'
 
 
-class TestResult(object):
+class TestResult(unittest.TestResult):
     """Holder for test result information.
 
     Test results are automatically managed by the TestCase and TestSuite
diff -u -x '*.pyc' --recursive --new-file cpython/Lib/unittest/suite.py unittest2/suite.py
--- cpython/Lib/unittest/suite.py	2011-03-24 02:43:51.000000000 -0400
+++ unittest2/suite.py	2011-03-25 21:38:23.000000000 -0400
@@ -1,6 +1,7 @@
 """TestSuite"""
 
 import sys
+import unittest
 
 from . import case
 from . import util
@@ -13,7 +14,7 @@
     func()
 
 
-class BaseTestSuite(object):
+class BaseTestSuite(unittest.TestSuite):
     """A simple test suite that doesn't provide class or module shared fixtures.
     """
     def __init__(self, tests=()):
@@ -43,7 +44,7 @@
     def addTest(self, test):
         # sanity checks
         if not hasattr(test, '__call__'):
-            raise TypeError("{} is not callable".format(repr(test)))
+            raise TypeError("{0} is not callable".format(repr(test)))
         if isinstance(test, type) and issubclass(test,
                                                  (case.TestCase, TestSuite)):
             raise TypeError("TestCases and TestSuites must be instantiated "
diff -u -x '*.pyc' --recursive --new-file cpython/Lib/unittest/suite.py.orig unittest2/suite.py.orig
--- cpython/Lib/unittest/suite.py.orig	1969-12-31 19:00:00.000000000 -0500
+++ unittest2/suite.py.orig	2011-03-25 21:38:23.000000000 -0400
@@ -0,0 +1,301 @@
+"""TestSuite"""
+
+import sys
+
+from . import case
+from . import util
+
+__unittest = True
+
+
+def _call_if_exists(parent, attr):
+    func = getattr(parent, attr, lambda: None)
+    func()
+
+
+class BaseTestSuite(object):
+    """A simple test suite that doesn't provide class or module shared fixtures.
+    """
+    def __init__(self, tests=()):
+        self._tests = []
+        self.addTests(tests)
+
+    def __repr__(self):
+        return "<%s tests=%s>" % (util.strclass(self.__class__), list(self))
+
+    def __eq__(self, other):
+        if not isinstance(other, self.__class__):
+            return NotImplemented
+        return list(self) == list(other)
+
+    def __ne__(self, other):
+        return not self == other
+
+    def __iter__(self):
+        return iter(self._tests)
+
+    def countTestCases(self):
+        cases = 0
+        for test in self:
+            cases += test.countTestCases()
+        return cases
+
+    def addTest(self, test):
+        # sanity checks
+        if not hasattr(test, '__call__'):
+            raise TypeError("{} is not callable".format(repr(test)))
+        if isinstance(test, type) and issubclass(test,
+                                                 (case.TestCase, TestSuite)):
+            raise TypeError("TestCases and TestSuites must be instantiated "
+                            "before passing them to addTest()")
+        self._tests.append(test)
+
+    def addTests(self, tests):
+        if isinstance(tests, str):
+            raise TypeError("tests must be an iterable of tests, not a string")
+        for test in tests:
+            self.addTest(test)
+
+    def run(self, result):
+        for test in self:
+            if result.shouldStop:
+                break
+            test(result)
+        return result
+
+    def __call__(self, *args, **kwds):
+        return self.run(*args, **kwds)
+
+    def debug(self):
+        """Run the tests without collecting errors in a TestResult"""
+        for test in self:
+            test.debug()
+
+
+class TestSuite(BaseTestSuite):
+    """A test suite is a composite test consisting of a number of TestCases.
+
+    For use, create an instance of TestSuite, then add test case instances.
+    When all tests have been added, the suite can be passed to a test
+    runner, such as TextTestRunner. It will run the individual test cases
+    in the order in which they were added, aggregating the results. When
+    subclassing, do not forget to call the base class constructor.
+    """
+
+    def run(self, result, debug=False):
+        topLevel = False
+        if getattr(result, '_testRunEntered', False) is False:
+            result._testRunEntered = topLevel = True
+
+        for test in self:
+            if result.shouldStop:
+                break
+
+            if _isnotsuite(test):
+                self._tearDownPreviousClass(test, result)
+                self._handleModuleFixture(test, result)
+                self._handleClassSetUp(test, result)
+                result._previousTestClass = test.__class__
+
+                if (getattr(test.__class__, '_classSetupFailed', False) or
+                    getattr(result, '_moduleSetUpFailed', False)):
+                    continue
+
+            if not debug:
+                test(result)
+            else:
+                test.debug()
+
+        if topLevel:
+            self._tearDownPreviousClass(None, result)
+            self._handleModuleTearDown(result)
+            result._testRunEntered = False
+        return result
+
+    def debug(self):
+        """Run the tests without collecting errors in a TestResult"""
+        debug = _DebugResult()
+        self.run(debug, True)
+
+    ################################
+
+    def _handleClassSetUp(self, test, result):
+        previousClass = getattr(result, '_previousTestClass', None)
+        currentClass = test.__class__
+        if currentClass == previousClass:
+            return
+        if result._moduleSetUpFailed:
+            return
+        if getattr(currentClass, "__unittest_skip__", False):
+            return
+
+        try:
+            currentClass._classSetupFailed = False
+        except TypeError:
+            # test may actually be a function
+            # so its class will be a builtin-type
+            pass
+
+        setUpClass = getattr(currentClass, 'setUpClass', None)
+        if setUpClass is not None:
+            _call_if_exists(result, '_setupStdout')
+            try:
+                setUpClass()
+            except Exception as e:
+                if isinstance(result, _DebugResult):
+                    raise
+                currentClass._classSetupFailed = True
+                className = util.strclass(currentClass)
+                errorName = 'setUpClass (%s)' % className
+                self._addClassOrModuleLevelException(result, e, errorName)
+            finally:
+                _call_if_exists(result, '_restoreStdout')
+
+    def _get_previous_module(self, result):
+        previousModule = None
+        previousClass = getattr(result, '_previousTestClass', None)
+        if previousClass is not None:
+            previousModule = previousClass.__module__
+        return previousModule
+
+
+    def _handleModuleFixture(self, test, result):
+        previousModule = self._get_previous_module(result)
+        currentModule = test.__class__.__module__
+        if currentModule == previousModule:
+            return
+
+        self._handleModuleTearDown(result)
+
+
+        result._moduleSetUpFailed = False
+        try:
+            module = sys.modules[currentModule]
+        except KeyError:
+            return
+        setUpModule = getattr(module, 'setUpModule', None)
+        if setUpModule is not None:
+            _call_if_exists(result, '_setupStdout')
+            try:
+                setUpModule()
+            except Exception as e:
+                if isinstance(result, _DebugResult):
+                    raise
+                result._moduleSetUpFailed = True
+                errorName = 'setUpModule (%s)' % currentModule
+                self._addClassOrModuleLevelException(result, e, errorName)
+            finally:
+                _call_if_exists(result, '_restoreStdout')
+
+    def _addClassOrModuleLevelException(self, result, exception, errorName):
+        error = _ErrorHolder(errorName)
+        addSkip = getattr(result, 'addSkip', None)
+        if addSkip is not None and isinstance(exception, case.SkipTest):
+            addSkip(error, str(exception))
+        else:
+            result.addError(error, sys.exc_info())
+
+    def _handleModuleTearDown(self, result):
+        previousModule = self._get_previous_module(result)
+        if previousModule is None:
+            return
+        if result._moduleSetUpFailed:
+            return
+
+        try:
+            module = sys.modules[previousModule]
+        except KeyError:
+            return
+
+        tearDownModule = getattr(module, 'tearDownModule', None)
+        if tearDownModule is not None:
+            _call_if_exists(result, '_setupStdout')
+            try:
+                tearDownModule()
+            except Exception as e:
+                if isinstance(result, _DebugResult):
+                    raise
+                errorName = 'tearDownModule (%s)' % previousModule
+                self._addClassOrModuleLevelException(result, e, errorName)
+            finally:
+                _call_if_exists(result, '_restoreStdout')
+
+    def _tearDownPreviousClass(self, test, result):
+        previousClass = getattr(result, '_previousTestClass', None)
+        currentClass = test.__class__
+        if currentClass == previousClass:
+            return
+        if getattr(previousClass, '_classSetupFailed', False):
+            return
+        if getattr(result, '_moduleSetUpFailed', False):
+            return
+        if getattr(previousClass, "__unittest_skip__", False):
+            return
+
+        tearDownClass = getattr(previousClass, 'tearDownClass', None)
+        if tearDownClass is not None:
+            _call_if_exists(result, '_setupStdout')
+            try:
+                tearDownClass()
+            except Exception as e:
+                if isinstance(result, _DebugResult):
+                    raise
+                className = util.strclass(previousClass)
+                errorName = 'tearDownClass (%s)' % className
+                self._addClassOrModuleLevelException(result, e, errorName)
+            finally:
+                _call_if_exists(result, '_restoreStdout')
+
+
+class _ErrorHolder(object):
+    """
+    Placeholder for a TestCase inside a result. As far as a TestResult
+    is concerned, this looks exactly like a unit test. Used to insert
+    arbitrary errors into a test suite run.
+    """
+    # Inspired by the ErrorHolder from Twisted:
+    # http://twistedmatrix.com/trac/browser/trunk/twisted/trial/runner.py
+
+    # attribute used by TestResult._exc_info_to_string
+    failureException = None
+
+    def __init__(self, description):
+        self.description = description
+
+    def id(self):
+        return self.description
+
+    def shortDescription(self):
+        return None
+
+    def __repr__(self):
+        return "<ErrorHolder description=%r>" % (self.description,)
+
+    def __str__(self):
+        return self.id()
+
+    def run(self, result):
+        # could call result.addError(...) - but this test-like object
+        # shouldn't be run anyway
+        pass
+
+    def __call__(self, result):
+        return self.run(result)
+
+    def countTestCases(self):
+        return 0
+
+def _isnotsuite(test):
+    "A crude way to tell apart testcases and suites with duck-typing"
+    try:
+        iter(test)
+    except TypeError:
+        return True
+    return False
+
+
+class _DebugResult(object):
+    "Used by the TestSuite to hold previous class when running in debug."
+    _previousTestClass = None
+    _moduleSetUpFailed = False
+    shouldStop = False
diff -u -x '*.pyc' --recursive --new-file cpython/Lib/unittest/test/support.py unittest2/test/support.py
--- cpython/Lib/unittest/test/support.py	2011-03-24 02:43:51.000000000 -0400
+++ unittest2/test/support.py	2011-03-25 21:38:23.000000000 -0400
@@ -1,4 +1,9 @@
-import unittest
+import unittest2 as unittest
+
+import contextlib
+import re
+import sys
+import warnings
 
 
 class TestEquality(object):
@@ -116,3 +121,86 @@
 
     def wasSuccessful(self):
         return True
+
+class WarningsRecorder(object):
+    """Convenience wrapper for the warnings list returned on
+       entry to the warnings.catch_warnings() context manager.
+    """
+    def __init__(self, warnings_list):
+        self._warnings = warnings_list
+        self._last = 0
+
+    def __getattr__(self, attr):
+        if len(self._warnings) > self._last:
+            return getattr(self._warnings[-1], attr)
+        elif attr in warnings.WarningMessage._WARNING_DETAILS:
+            return None
+        raise AttributeError("%r has no attribute %r" % (self, attr))
+
+    @property
+    def warnings(self):
+        return self._warnings[self._last:]
+
+    def reset(self):
+        self._last = len(self._warnings)
+
+def _filterwarnings(filters, quiet=False):
+    """Catch the warnings, then check if all the expected
+    warnings have been raised and re-raise unexpected warnings.
+    If 'quiet' is True, only re-raise the unexpected warnings.
+    """
+    # Clear the warning registry of the calling module
+    # in order to re-raise the warnings.
+    frame = sys._getframe(2)
+    registry = frame.f_globals.get('__warningregistry__')
+    if registry:
+        registry.clear()
+    with warnings.catch_warnings(record=True) as w:
+        # Set filter "always" to record all warnings.  Because
+        # test_warnings swap the module, we need to look up in
+        # the sys.modules dictionary.
+        sys.modules['warnings'].simplefilter("always")
+        yield WarningsRecorder(w)
+    # Filter the recorded warnings
+    reraise = [warning.message for warning in w]
+    missing = []
+    for msg, cat in filters:
+        seen = False
+        for exc in reraise[:]:
+            message = str(exc)
+            # Filter out the matching messages
+            if (re.match(msg, message, re.I) and
+                issubclass(exc.__class__, cat)):
+                seen = True
+                reraise.remove(exc)
+        if not seen and not quiet:
+            # This filter caught nothing
+            missing.append((msg, cat.__name__))
+    if reraise:
+        raise AssertionError("unhandled warning %r" % reraise[0])
+    if missing:
+        raise AssertionError("filter (%r, %s) did not catch any warning" %
+                             missing[0])
+
+@contextlib.contextmanager
+def check_warnings(*filters, **kwargs):
+    """Context manager to silence warnings.
+
+    Accept 2-tuples as positional arguments:
+        ("message regexp", WarningCategory)
+
+    Optional argument:
+     - if 'quiet' is True, it does not fail if a filter catches nothing
+        (default True without argument,
+         default False if some filters are defined)
+
+    Without argument, it defaults to:
+        check_warnings(("", Warning), quiet=True)
+    """
+    quiet = kwargs.get('quiet')
+    if not filters:
+        filters = (("", Warning),)
+        # Preserve backward compatibility
+        if quiet is None:
+            quiet = True
+    return _filterwarnings(filters, quiet)
diff -u -x '*.pyc' --recursive --new-file cpython/Lib/unittest/test/test_assertions.py unittest2/test/test_assertions.py
--- cpython/Lib/unittest/test/test_assertions.py	2011-03-24 02:43:51.000000000 -0400
+++ unittest2/test/test_assertions.py	2011-03-25 21:38:23.000000000 -0400
@@ -1,6 +1,6 @@
 import datetime
 import warnings
-import unittest
+import unittest2 as unittest
 
 
 class Test_Assertions(unittest.TestCase):
diff -u -x '*.pyc' --recursive --new-file cpython/Lib/unittest/test/test_break.py unittest2/test/test_break.py
--- cpython/Lib/unittest/test/test_break.py	2011-03-24 02:43:51.000000000 -0400
+++ unittest2/test/test_break.py	2011-03-25 21:38:23.000000000 -0400
@@ -5,7 +5,7 @@
 import signal
 import weakref
 
-import unittest
+import unittest2 as unittest
 
 
 @unittest.skipUnless(hasattr(os, 'kill'), "Test requires os.kill")
diff -u -x '*.pyc' --recursive --new-file cpython/Lib/unittest/test/test_case.py unittest2/test/test_case.py
--- cpython/Lib/unittest/test/test_case.py	2011-03-24 02:43:51.000000000 -0400
+++ unittest2/test/test_case.py	2011-03-25 21:38:23.000000000 -0400
@@ -9,7 +9,7 @@
 from copy import deepcopy
 from test import support
 
-import unittest
+import unittest2 as unittest
 
 from .support import (
     TestEquality, TestHashing, LoggingResult,
@@ -752,6 +752,10 @@
         expected = {(3,1,'a'), (1,3,'b'), (1,0,'d'), (0,1,'e')}
         self.assertEqual(diffs, expected)
 
+    def testCountEqualAlias(self):
+        self.assertTrue(hasattr(unittest.TestCase, 'assertItemsEqual'))
+        self.assertTrue(unittest.TestCase.assertItemsEqual is unittest.TestCase.assertCountEqual)
+
     def testAssertSetEqual(self):
         set1 = set()
         set2 = set()
@@ -1217,3 +1221,7 @@
             klass('test_something').run(result)
             self.assertEqual(len(result.errors), 1)
             self.assertEqual(result.testsRun, 1)
+
+    def testBaseClassInheritance(self):
+        import unittest as unittestorig
+        self.assertTrue(issubclass(unittest.TestCase, unittestorig.TestCase))
diff -u -x '*.pyc' --recursive --new-file cpython/Lib/unittest/test/test_case.py.orig unittest2/test/test_case.py.orig
--- cpython/Lib/unittest/test/test_case.py.orig	1969-12-31 19:00:00.000000000 -0500
+++ unittest2/test/test_case.py.orig	2011-03-25 21:38:23.000000000 -0400
@@ -0,0 +1,1219 @@
+import difflib
+import pprint
+import pickle
+import re
+import sys
+import warnings
+import inspect
+
+from copy import deepcopy
+from test import support
+
+import unittest
+
+from .support import (
+    TestEquality, TestHashing, LoggingResult,
+    ResultWithNoStartTestRunStopTestRun
+)
+
+
+class Test(object):
+    "Keep these TestCase classes out of the main namespace"
+
+    class Foo(unittest.TestCase):
+        def runTest(self): pass
+        def test1(self): pass
+
+    class Bar(Foo):
+        def test2(self): pass
+
+    class LoggingTestCase(unittest.TestCase):
+        """A test case which logs its calls."""
+
+        def __init__(self, events):
+            super(Test.LoggingTestCase, self).__init__('test')
+            self.events = events
+
+        def setUp(self):
+            self.events.append('setUp')
+
+        def test(self):
+            self.events.append('test')
+
+        def tearDown(self):
+            self.events.append('tearDown')
+
+
+class Test_TestCase(unittest.TestCase, TestEquality, TestHashing):
+
+    ### Set up attributes used by inherited tests
+    ################################################################
+
+    # Used by TestHashing.test_hash and TestEquality.test_eq
+    eq_pairs = [(Test.Foo('test1'), Test.Foo('test1'))]
+
+    # Used by TestEquality.test_ne
+    ne_pairs = [(Test.Foo('test1'), Test.Foo('runTest')),
+                (Test.Foo('test1'), Test.Bar('test1')),
+                (Test.Foo('test1'), Test.Bar('test2'))]
+
+    ################################################################
+    ### /Set up attributes used by inherited tests
+
+
+    # "class TestCase([methodName])"
+    # ...
+    # "Each instance of TestCase will run a single test method: the
+    # method named methodName."
+    # ...
+    # "methodName defaults to "runTest"."
+    #
+    # Make sure it really is optional, and that it defaults to the proper
+    # thing.
+    def test_init__no_test_name(self):
+        class Test(unittest.TestCase):
+            def runTest(self): raise MyException()
+            def test(self): pass
+
+        self.assertEqual(Test().id()[-13:], '.Test.runTest')
+
+        # test that TestCase can be instantiated with no args
+        # primarily for use at the interactive interpreter
+        test = unittest.TestCase()
+        test.assertEqual(3, 3)
+        with test.assertRaises(test.failureException):
+            test.assertEqual(3, 2)
+
+        with self.assertRaises(AttributeError):
+            test.run()
+
+    # "class TestCase([methodName])"
+    # ...
+    # "Each instance of TestCase will run a single test method: the
+    # method named methodName."
+    def test_init__test_name__valid(self):
+        class Test(unittest.TestCase):
+            def runTest(self): raise MyException()
+            def test(self): pass
+
+        self.assertEqual(Test('test').id()[-10:], '.Test.test')
+
+    # "class TestCase([methodName])"
+    # ...
+    # "Each instance of TestCase will run a single test method: the
+    # method named methodName."
+    def test_init__test_name__invalid(self):
+        class Test(unittest.TestCase):
+            def runTest(self): raise MyException()
+            def test(self): pass
+
+        try:
+            Test('testfoo')
+        except ValueError:
+            pass
+        else:
+            self.fail("Failed to raise ValueError")
+
+    # "Return the number of tests represented by the this test object. For
+    # TestCase instances, this will always be 1"
+    def test_countTestCases(self):
+        class Foo(unittest.TestCase):
+            def test(self): pass
+
+        self.assertEqual(Foo('test').countTestCases(), 1)
+
+    # "Return the default type of test result object to be used to run this
+    # test. For TestCase instances, this will always be
+    # unittest.TestResult;  subclasses of TestCase should
+    # override this as necessary."
+    def test_defaultTestResult(self):
+        class Foo(unittest.TestCase):
+            def runTest(self):
+                pass
+
+        result = Foo().defaultTestResult()
+        self.assertEqual(type(result), unittest.TestResult)
+
+    # "When a setUp() method is defined, the test runner will run that method
+    # prior to each test. Likewise, if a tearDown() method is defined, the
+    # test runner will invoke that method after each test. In the example,
+    # setUp() was used to create a fresh sequence for each test."
+    #
+    # Make sure the proper call order is maintained, even if setUp() raises
+    # an exception.
+    def test_run_call_order__error_in_setUp(self):
+        events = []
+        result = LoggingResult(events)
+
+        class Foo(Test.LoggingTestCase):
+            def setUp(self):
+                super(Foo, self).setUp()
+                raise RuntimeError('raised by Foo.setUp')
+
+        Foo(events).run(result)
+        expected = ['startTest', 'setUp', 'addError', 'stopTest']
+        self.assertEqual(events, expected)
+
+    # "With a temporary result stopTestRun is called when setUp errors.
+    def test_run_call_order__error_in_setUp_default_result(self):
+        events = []
+
+        class Foo(Test.LoggingTestCase):
+            def defaultTestResult(self):
+                return LoggingResult(self.events)
+
+            def setUp(self):
+                super(Foo, self).setUp()
+                raise RuntimeError('raised by Foo.setUp')
+
+        Foo(events).run()
+        expected = ['startTestRun', 'startTest', 'setUp', 'addError',
+                    'stopTest', 'stopTestRun']
+        self.assertEqual(events, expected)
+
+    # "When a setUp() method is defined, the test runner will run that method
+    # prior to each test. Likewise, if a tearDown() method is defined, the
+    # test runner will invoke that method after each test. In the example,
+    # setUp() was used to create a fresh sequence for each test."
+    #
+    # Make sure the proper call order is maintained, even if the test raises
+    # an error (as opposed to a failure).
+    def test_run_call_order__error_in_test(self):
+        events = []
+        result = LoggingResult(events)
+
+        class Foo(Test.LoggingTestCase):
+            def test(self):
+                super(Foo, self).test()
+                raise RuntimeError('raised by Foo.test')
+
+        expected = ['startTest', 'setUp', 'test', 'tearDown',
+                    'addError', 'stopTest']
+        Foo(events).run(result)
+        self.assertEqual(events, expected)
+
+    # "With a default result, an error in the test still results in stopTestRun
+    # being called."
+    def test_run_call_order__error_in_test_default_result(self):
+        events = []
+
+        class Foo(Test.LoggingTestCase):
+            def defaultTestResult(self):
+                return LoggingResult(self.events)
+
+            def test(self):
+                super(Foo, self).test()
+                raise RuntimeError('raised by Foo.test')
+
+        expected = ['startTestRun', 'startTest', 'setUp', 'test',
+                    'tearDown', 'addError', 'stopTest', 'stopTestRun']
+        Foo(events).run()
+        self.assertEqual(events, expected)
+
+    # "When a setUp() method is defined, the test runner will run that method
+    # prior to each test. Likewise, if a tearDown() method is defined, the
+    # test runner will invoke that method after each test. In the example,
+    # setUp() was used to create a fresh sequence for each test."
+    #
+    # Make sure the proper call order is maintained, even if the test signals
+    # a failure (as opposed to an error).
+    def test_run_call_order__failure_in_test(self):
+        events = []
+        result = LoggingResult(events)
+
+        class Foo(Test.LoggingTestCase):
+            def test(self):
+                super(Foo, self).test()
+                self.fail('raised by Foo.test')
+
+        expected = ['startTest', 'setUp', 'test', 'tearDown',
+                    'addFailure', 'stopTest']
+        Foo(events).run(result)
+        self.assertEqual(events, expected)
+
+    # "When a test fails with a default result stopTestRun is still called."
+    def test_run_call_order__failure_in_test_default_result(self):
+
+        class Foo(Test.LoggingTestCase):
+            def defaultTestResult(self):
+                return LoggingResult(self.events)
+            def test(self):
+                super(Foo, self).test()
+                self.fail('raised by Foo.test')
+
+        expected = ['startTestRun', 'startTest', 'setUp', 'test',
+                    'tearDown', 'addFailure', 'stopTest', 'stopTestRun']
+        events = []
+        Foo(events).run()
+        self.assertEqual(events, expected)
+
+    # "When a setUp() method is defined, the test runner will run that method
+    # prior to each test. Likewise, if a tearDown() method is defined, the
+    # test runner will invoke that method after each test. In the example,
+    # setUp() was used to create a fresh sequence for each test."
+    #
+    # Make sure the proper call order is maintained, even if tearDown() raises
+    # an exception.
+    def test_run_call_order__error_in_tearDown(self):
+        events = []
+        result = LoggingResult(events)
+
+        class Foo(Test.LoggingTestCase):
+            def tearDown(self):
+                super(Foo, self).tearDown()
+                raise RuntimeError('raised by Foo.tearDown')
+
+        Foo(events).run(result)
+        expected = ['startTest', 'setUp', 'test', 'tearDown', 'addError',
+                    'stopTest']
+        self.assertEqual(events, expected)
+
+    # "When tearDown errors with a default result stopTestRun is still called."
+    def test_run_call_order__error_in_tearDown_default_result(self):
+
+        class Foo(Test.LoggingTestCase):
+            def defaultTestResult(self):
+                return LoggingResult(self.events)
+            def tearDown(self):
+                super(Foo, self).tearDown()
+                raise RuntimeError('raised by Foo.tearDown')
+
+        events = []
+        Foo(events).run()
+        expected = ['startTestRun', 'startTest', 'setUp', 'test', 'tearDown',
+                    'addError', 'stopTest', 'stopTestRun']
+        self.assertEqual(events, expected)
+
+    # "TestCase.run() still works when the defaultTestResult is a TestResult
+    # that does not support startTestRun and stopTestRun.
+    def test_run_call_order_default_result(self):
+
+        class Foo(unittest.TestCase):
+            def defaultTestResult(self):
+                return ResultWithNoStartTestRunStopTestRun()
+            def test(self):
+                pass
+
+        Foo('test').run()
+
+    # "This class attribute gives the exception raised by the test() method.
+    # If a test framework needs to use a specialized exception, possibly to
+    # carry additional information, it must subclass this exception in
+    # order to ``play fair'' with the framework.  The initial value of this
+    # attribute is AssertionError"
+    def test_failureException__default(self):
+        class Foo(unittest.TestCase):
+            def test(self):
+                pass
+
+        self.assertTrue(Foo('test').failureException is AssertionError)
+
+    # "This class attribute gives the exception raised by the test() method.
+    # If a test framework needs to use a specialized exception, possibly to
+    # carry additional information, it must subclass this exception in
+    # order to ``play fair'' with the framework."
+    #
+    # Make sure TestCase.run() respects the designated failureException
+    def test_failureException__subclassing__explicit_raise(self):
+        events = []
+        result = LoggingResult(events)
+
+        class Foo(unittest.TestCase):
+            def test(self):
+                raise RuntimeError()
+
+            failureException = RuntimeError
+
+        self.assertTrue(Foo('test').failureException is RuntimeError)
+
+
+        Foo('test').run(result)
+        expected = ['startTest', 'addFailure', 'stopTest']
+        self.assertEqual(events, expected)
+
+    # "This class attribute gives the exception raised by the test() method.
+    # If a test framework needs to use a specialized exception, possibly to
+    # carry additional information, it must subclass this exception in
+    # order to ``play fair'' with the framework."
+    #
+    # Make sure TestCase.run() respects the designated failureException
+    def test_failureException__subclassing__implicit_raise(self):
+        events = []
+        result = LoggingResult(events)
+
+        class Foo(unittest.TestCase):
+            def test(self):
+                self.fail("foo")
+
+            failureException = RuntimeError
+
+        self.assertTrue(Foo('test').failureException is RuntimeError)
+
+
+        Foo('test').run(result)
+        expected = ['startTest', 'addFailure', 'stopTest']
+        self.assertEqual(events, expected)
+
+    # "The default implementation does nothing."
+    def test_setUp(self):
+        class Foo(unittest.TestCase):
+            def runTest(self):
+                pass
+
+        # ... and nothing should happen
+        Foo().setUp()
+
+    # "The default implementation does nothing."
+    def test_tearDown(self):
+        class Foo(unittest.TestCase):
+            def runTest(self):
+                pass
+
+        # ... and nothing should happen
+        Foo().tearDown()
+
+    # "Return a string identifying the specific test case."
+    #
+    # Because of the vague nature of the docs, I'm not going to lock this
+    # test down too much. Really all that can be asserted is that the id()
+    # will be a string (either 8-byte or unicode -- again, because the docs
+    # just say "string")
+    def test_id(self):
+        class Foo(unittest.TestCase):
+            def runTest(self):
+                pass
+
+        self.assertIsInstance(Foo().id(), str)
+
+
+    # "If result is omitted or None, a temporary result object is created,
+    # used, and is made available to the caller. As TestCase owns the
+    # temporary result startTestRun and stopTestRun are called.
+
+    def test_run__uses_defaultTestResult(self):
+        events = []
+        defaultResult = LoggingResult(events)
+
+        class Foo(unittest.TestCase):
+            def test(self):
+                events.append('test')
+
+            def defaultTestResult(self):
+                return defaultResult
+
+        # Make run() find a result object on its own
+        result = Foo('test').run()
+
+        self.assertIs(result, defaultResult)
+        expected = ['startTestRun', 'startTest', 'test', 'addSuccess',
+            'stopTest', 'stopTestRun']
+        self.assertEqual(events, expected)
+
+
+    # "The result object is returned to run's caller"
+    def test_run__returns_given_result(self):
+
+        class Foo(unittest.TestCase):
+            def test(self):
+                pass
+
+        result = unittest.TestResult()
+
+        retval = Foo('test').run(result)
+        self.assertIs(retval, result)
+
+
+    # "The same effect [as method run] may be had by simply calling the
+    # TestCase instance."
+    def test_call__invoking_an_instance_delegates_to_run(self):
+        resultIn = unittest.TestResult()
+        resultOut = unittest.TestResult()
+
+        class Foo(unittest.TestCase):
+            def test(self):
+                pass
+
+            def run(self, result):
+                self.assertIs(result, resultIn)
+                return resultOut
+
+        retval = Foo('test')(resultIn)
+
+        self.assertIs(retval, resultOut)
+
+
+    def testShortDescriptionWithoutDocstring(self):
+        self.assertIsNone(self.shortDescription())
+
+    @unittest.skipIf(sys.flags.optimize >= 2,
+                     "Docstrings are omitted with -O2 and above")
+    def testShortDescriptionWithOneLineDocstring(self):
+        """Tests shortDescription() for a method with a docstring."""
+        self.assertEqual(
+                self.shortDescription(),
+                'Tests shortDescription() for a method with a docstring.')
+
+    @unittest.skipIf(sys.flags.optimize >= 2,
+                     "Docstrings are omitted with -O2 and above")
+    def testShortDescriptionWithMultiLineDocstring(self):
+        """Tests shortDescription() for a method with a longer docstring.
+
+        This method ensures that only the first line of a docstring is
+        returned used in the short description, no matter how long the
+        whole thing is.
+        """
+        self.assertEqual(
+                self.shortDescription(),
+                 'Tests shortDescription() for a method with a longer '
+                 'docstring.')
+
+    def testAddTypeEqualityFunc(self):
+        class SadSnake(object):
+            """Dummy class for test_addTypeEqualityFunc."""
+        s1, s2 = SadSnake(), SadSnake()
+        self.assertFalse(s1 == s2)
+        def AllSnakesCreatedEqual(a, b, msg=None):
+            return type(a) == type(b) == SadSnake
+        self.addTypeEqualityFunc(SadSnake, AllSnakesCreatedEqual)
+        self.assertEqual(s1, s2)
+        # No this doesn't clean up and remove the SadSnake equality func
+        # from this TestCase instance but since its a local nothing else
+        # will ever notice that.
+
+    def testAssertIs(self):
+        thing = object()
+        self.assertIs(thing, thing)
+        self.assertRaises(self.failureException, self.assertIs, thing, object())
+
+    def testAssertIsNot(self):
+        thing = object()
+        self.assertIsNot(thing, object())
+        self.assertRaises(self.failureException, self.assertIsNot, thing, thing)
+
+    def testAssertIsInstance(self):
+        thing = []
+        self.assertIsInstance(thing, list)
+        self.assertRaises(self.failureException, self.assertIsInstance,
+                          thing, dict)
+
+    def testAssertNotIsInstance(self):
+        thing = []
+        self.assertNotIsInstance(thing, dict)
+        self.assertRaises(self.failureException, self.assertNotIsInstance,
+                          thing, list)
+
+    def testAssertIn(self):
+        animals = {'monkey': 'banana', 'cow': 'grass', 'seal': 'fish'}
+
+        self.assertIn('a', 'abc')
+        self.assertIn(2, [1, 2, 3])
+        self.assertIn('monkey', animals)
+
+        self.assertNotIn('d', 'abc')
+        self.assertNotIn(0, [1, 2, 3])
+        self.assertNotIn('otter', animals)
+
+        self.assertRaises(self.failureException, self.assertIn, 'x', 'abc')
+        self.assertRaises(self.failureException, self.assertIn, 4, [1, 2, 3])
+        self.assertRaises(self.failureException, self.assertIn, 'elephant',
+                          animals)
+
+        self.assertRaises(self.failureException, self.assertNotIn, 'c', 'abc')
+        self.assertRaises(self.failureException, self.assertNotIn, 1, [1, 2, 3])
+        self.assertRaises(self.failureException, self.assertNotIn, 'cow',
+                          animals)
+
+    def testAssertEqual(self):
+        equal_pairs = [
+                ((), ()),
+                ({}, {}),
+                ([], []),
+                (set(), set()),
+                (frozenset(), frozenset())]
+        for a, b in equal_pairs:
+            # This mess of try excepts is to test the assertEqual behavior
+            # itself.
+            try:
+                self.assertEqual(a, b)
+            except self.failureException:
+                self.fail('assertEqual(%r, %r) failed' % (a, b))
+            try:
+                self.assertEqual(a, b, msg='foo')
+            except self.failureException:
+                self.fail('assertEqual(%r, %r) with msg= failed' % (a, b))
+            try:
+                self.assertEqual(a, b, 'foo')
+            except self.failureException:
+                self.fail('assertEqual(%r, %r) with third parameter failed' %
+                          (a, b))
+
+        unequal_pairs = [
+               ((), []),
+               ({}, set()),
+               (set([4,1]), frozenset([4,2])),
+               (frozenset([4,5]), set([2,3])),
+               (set([3,4]), set([5,4]))]
+        for a, b in unequal_pairs:
+            self.assertRaises(self.failureException, self.assertEqual, a, b)
+            self.assertRaises(self.failureException, self.assertEqual, a, b,
+                              'foo')
+            self.assertRaises(self.failureException, self.assertEqual, a, b,
+                              msg='foo')
+
+    def testEquality(self):
+        self.assertListEqual([], [])
+        self.assertTupleEqual((), ())
+        self.assertSequenceEqual([], ())
+
+        a = [0, 'a', []]
+        b = []
+        self.assertRaises(unittest.TestCase.failureException,
+                          self.assertListEqual, a, b)
+        self.assertRaises(unittest.TestCase.failureException,
+                          self.assertListEqual, tuple(a), tuple(b))
+        self.assertRaises(unittest.TestCase.failureException,
+                          self.assertSequenceEqual, a, tuple(b))
+
+        b.extend(a)
+        self.assertListEqual(a, b)
+        self.assertTupleEqual(tuple(a), tuple(b))
+        self.assertSequenceEqual(a, tuple(b))
+        self.assertSequenceEqual(tuple(a), b)
+
+        self.assertRaises(self.failureException, self.assertListEqual,
+                          a, tuple(b))
+        self.assertRaises(self.failureException, self.assertTupleEqual,
+                          tuple(a), b)
+        self.assertRaises(self.failureException, self.assertListEqual, None, b)
+        self.assertRaises(self.failureException, self.assertTupleEqual, None,
+                          tuple(b))
+        self.assertRaises(self.failureException, self.assertSequenceEqual,
+                          None, tuple(b))
+        self.assertRaises(self.failureException, self.assertListEqual, 1, 1)
+        self.assertRaises(self.failureException, self.assertTupleEqual, 1, 1)
+        self.assertRaises(self.failureException, self.assertSequenceEqual,
+                          1, 1)
+
+        self.assertDictEqual({}, {})
+
+        c = { 'x': 1 }
+        d = {}
+        self.assertRaises(unittest.TestCase.failureException,
+                          self.assertDictEqual, c, d)
+
+        d.update(c)
+        self.assertDictEqual(c, d)
+
+        d['x'] = 0
+        self.assertRaises(unittest.TestCase.failureException,
+                          self.assertDictEqual, c, d, 'These are unequal')
+
+        self.assertRaises(self.failureException, self.assertDictEqual, None, d)
+        self.assertRaises(self.failureException, self.assertDictEqual, [], d)
+        self.assertRaises(self.failureException, self.assertDictEqual, 1, 1)
+
+    def testAssertSequenceEqualMaxDiff(self):
+        self.assertEqual(self.maxDiff, 80*8)
+        seq1 = 'a' + 'x' * 80**2
+        seq2 = 'b' + 'x' * 80**2
+        diff = '\n'.join(difflib.ndiff(pprint.pformat(seq1).splitlines(),
+                                       pprint.pformat(seq2).splitlines()))
+        # the +1 is the leading \n added by assertSequenceEqual
+        omitted = unittest.case.DIFF_OMITTED % (len(diff) + 1,)
+
+        self.maxDiff = len(diff)//2
+        try:
+
+            self.assertSequenceEqual(seq1, seq2)
+        except self.failureException as e:
+            msg = e.args[0]
+        else:
+            self.fail('assertSequenceEqual did not fail.')
+        self.assertTrue(len(msg) < len(diff))
+        self.assertIn(omitted, msg)
+
+        self.maxDiff = len(diff) * 2
+        try:
+            self.assertSequenceEqual(seq1, seq2)
+        except self.failureException as e:
+            msg = e.args[0]
+        else:
+            self.fail('assertSequenceEqual did not fail.')
+        self.assertTrue(len(msg) > len(diff))
+        self.assertNotIn(omitted, msg)
+
+        self.maxDiff = None
+        try:
+            self.assertSequenceEqual(seq1, seq2)
+        except self.failureException as e:
+            msg = e.args[0]
+        else:
+            self.fail('assertSequenceEqual did not fail.')
+        self.assertTrue(len(msg) > len(diff))
+        self.assertNotIn(omitted, msg)
+
+    def testTruncateMessage(self):
+        self.maxDiff = 1
+        message = self._truncateMessage('foo', 'bar')
+        omitted = unittest.case.DIFF_OMITTED % len('bar')
+        self.assertEqual(message, 'foo' + omitted)
+
+        self.maxDiff = None
+        message = self._truncateMessage('foo', 'bar')
+        self.assertEqual(message, 'foobar')
+
+        self.maxDiff = 4
+        message = self._truncateMessage('foo', 'bar')
+        self.assertEqual(message, 'foobar')
+
+    def testAssertDictEqualTruncates(self):
+        test = unittest.TestCase('assertEqual')
+        def truncate(msg, diff):
+            return 'foo'
+        test._truncateMessage = truncate
+        try:
+            test.assertDictEqual({}, {1: 0})
+        except self.failureException as e:
+            self.assertEqual(str(e), 'foo')
+        else:
+            self.fail('assertDictEqual did not fail')
+
+    def testAssertMultiLineEqualTruncates(self):
+        test = unittest.TestCase('assertEqual')
+        def truncate(msg, diff):
+            return 'foo'
+        test._truncateMessage = truncate
+        try:
+            test.assertMultiLineEqual('foo', 'bar')
+        except self.failureException as e:
+            self.assertEqual(str(e), 'foo')
+        else:
+            self.fail('assertMultiLineEqual did not fail')
+
+    def testAssertCountEqual(self):
+        a = object()
+        self.assertCountEqual([1, 2, 3], [3, 2, 1])
+        self.assertCountEqual(['foo', 'bar', 'baz'], ['bar', 'baz', 'foo'])
+        self.assertCountEqual([a, a, 2, 2, 3], (a, 2, 3, a, 2))
+        self.assertCountEqual([1, "2", "a", "a"], ["a", "2", True, "a"])
+        self.assertRaises(self.failureException, self.assertCountEqual,
+                          [1, 2] + [3] * 100, [1] * 100 + [2, 3])
+        self.assertRaises(self.failureException, self.assertCountEqual,
+                          [1, "2", "a", "a"], ["a", "2", True, 1])
+        self.assertRaises(self.failureException, self.assertCountEqual,
+                          [10], [10, 11])
+        self.assertRaises(self.failureException, self.assertCountEqual,
+                          [10, 11], [10])
+        self.assertRaises(self.failureException, self.assertCountEqual,
+                          [10, 11, 10], [10, 11])
+
+        # Test that sequences of unhashable objects can be tested for sameness:
+        self.assertCountEqual([[1, 2], [3, 4], 0], [False, [3, 4], [1, 2]])
+        # Test that iterator of unhashable objects can be tested for sameness:
+        self.assertCountEqual(iter([1, 2, [], 3, 4]),
+                              iter([1, 2, [], 3, 4]))
+
+        # hashable types, but not orderable
+        self.assertRaises(self.failureException, self.assertCountEqual,
+                          [], [divmod, 'x', 1, 5j, 2j, frozenset()])
+        # comparing dicts
+        self.assertCountEqual([{'a': 1}, {'b': 2}], [{'b': 2}, {'a': 1}])
+        # comparing heterogenous non-hashable sequences
+        self.assertCountEqual([1, 'x', divmod, []], [divmod, [], 'x', 1])
+        self.assertRaises(self.failureException, self.assertCountEqual,
+                          [], [divmod, [], 'x', 1, 5j, 2j, set()])
+        self.assertRaises(self.failureException, self.assertCountEqual,
+                          [[1]], [[2]])
+
+        # Same elements, but not same sequence length
+        self.assertRaises(self.failureException, self.assertCountEqual,
+                          [1, 1, 2], [2, 1])
+        self.assertRaises(self.failureException, self.assertCountEqual,
+                          [1, 1, "2", "a", "a"], ["2", "2", True, "a"])
+        self.assertRaises(self.failureException, self.assertCountEqual,
+                          [1, {'b': 2}, None, True], [{'b': 2}, True, None])
+
+        # Same elements which don't reliably compare, in
+        # different order, see issue 10242
+        a = [{2,4}, {1,2}]
+        b = a[::-1]
+        self.assertCountEqual(a, b)
+
+        # test utility functions supporting assertCountEqual()
+
+        diffs = set(unittest.util._count_diff_all_purpose('aaabccd', 'abbbcce'))
+        expected = {(3,1,'a'), (1,3,'b'), (1,0,'d'), (0,1,'e')}
+        self.assertEqual(diffs, expected)
+
+        diffs = unittest.util._count_diff_all_purpose([[]], [])
+        self.assertEqual(diffs, [(1, 0, [])])
+
+        diffs = set(unittest.util._count_diff_hashable('aaabccd', 'abbbcce'))
+        expected = {(3,1,'a'), (1,3,'b'), (1,0,'d'), (0,1,'e')}
+        self.assertEqual(diffs, expected)
+
+    def testAssertSetEqual(self):
+        set1 = set()
+        set2 = set()
+        self.assertSetEqual(set1, set2)
+
+        self.assertRaises(self.failureException, self.assertSetEqual, None, set2)
+        self.assertRaises(self.failureException, self.assertSetEqual, [], set2)
+        self.assertRaises(self.failureException, self.assertSetEqual, set1, None)
+        self.assertRaises(self.failureException, self.assertSetEqual, set1, [])
+
+        set1 = set(['a'])
+        set2 = set()
+        self.assertRaises(self.failureException, self.assertSetEqual, set1, set2)
+
+        set1 = set(['a'])
+        set2 = set(['a'])
+        self.assertSetEqual(set1, set2)
+
+        set1 = set(['a'])
+        set2 = set(['a', 'b'])
+        self.assertRaises(self.failureException, self.assertSetEqual, set1, set2)
+
+        set1 = set(['a'])
+        set2 = frozenset(['a', 'b'])
+        self.assertRaises(self.failureException, self.assertSetEqual, set1, set2)
+
+        set1 = set(['a', 'b'])
+        set2 = frozenset(['a', 'b'])
+        self.assertSetEqual(set1, set2)
+
+        set1 = set()
+        set2 = "foo"
+        self.assertRaises(self.failureException, self.assertSetEqual, set1, set2)
+        self.assertRaises(self.failureException, self.assertSetEqual, set2, set1)
+
+        # make sure any string formatting is tuple-safe
+        set1 = set([(0, 1), (2, 3)])
+        set2 = set([(4, 5)])
+        self.assertRaises(self.failureException, self.assertSetEqual, set1, set2)
+
+    def testInequality(self):
+        # Try ints
+        self.assertGreater(2, 1)
+        self.assertGreaterEqual(2, 1)
+        self.assertGreaterEqual(1, 1)
+        self.assertLess(1, 2)
+        self.assertLessEqual(1, 2)
+        self.assertLessEqual(1, 1)
+        self.assertRaises(self.failureException, self.assertGreater, 1, 2)
+        self.assertRaises(self.failureException, self.assertGreater, 1, 1)
+        self.assertRaises(self.failureException, self.assertGreaterEqual, 1, 2)
+        self.assertRaises(self.failureException, self.assertLess, 2, 1)
+        self.assertRaises(self.failureException, self.assertLess, 1, 1)
+        self.assertRaises(self.failureException, self.assertLessEqual, 2, 1)
+
+        # Try Floats
+        self.assertGreater(1.1, 1.0)
+        self.assertGreaterEqual(1.1, 1.0)
+        self.assertGreaterEqual(1.0, 1.0)
+        self.assertLess(1.0, 1.1)
+        self.assertLessEqual(1.0, 1.1)
+        self.assertLessEqual(1.0, 1.0)
+        self.assertRaises(self.failureException, self.assertGreater, 1.0, 1.1)
+        self.assertRaises(self.failureException, self.assertGreater, 1.0, 1.0)
+        self.assertRaises(self.failureException, self.assertGreaterEqual, 1.0, 1.1)
+        self.assertRaises(self.failureException, self.assertLess, 1.1, 1.0)
+        self.assertRaises(self.failureException, self.assertLess, 1.0, 1.0)
+        self.assertRaises(self.failureException, self.assertLessEqual, 1.1, 1.0)
+
+        # Try Strings
+        self.assertGreater('bug', 'ant')
+        self.assertGreaterEqual('bug', 'ant')
+        self.assertGreaterEqual('ant', 'ant')
+        self.assertLess('ant', 'bug')
+        self.assertLessEqual('ant', 'bug')
+        self.assertLessEqual('ant', 'ant')
+        self.assertRaises(self.failureException, self.assertGreater, 'ant', 'bug')
+        self.assertRaises(self.failureException, self.assertGreater, 'ant', 'ant')
+        self.assertRaises(self.failureException, self.assertGreaterEqual, 'ant', 'bug')
+        self.assertRaises(self.failureException, self.assertLess, 'bug', 'ant')
+        self.assertRaises(self.failureException, self.assertLess, 'ant', 'ant')
+        self.assertRaises(self.failureException, self.assertLessEqual, 'bug', 'ant')
+
+        # Try bytes
+        self.assertGreater(b'bug', b'ant')
+        self.assertGreaterEqual(b'bug', b'ant')
+        self.assertGreaterEqual(b'ant', b'ant')
+        self.assertLess(b'ant', b'bug')
+        self.assertLessEqual(b'ant', b'bug')
+        self.assertLessEqual(b'ant', b'ant')
+        self.assertRaises(self.failureException, self.assertGreater, b'ant', b'bug')
+        self.assertRaises(self.failureException, self.assertGreater, b'ant', b'ant')
+        self.assertRaises(self.failureException, self.assertGreaterEqual, b'ant',
+                          b'bug')
+        self.assertRaises(self.failureException, self.assertLess, b'bug', b'ant')
+        self.assertRaises(self.failureException, self.assertLess, b'ant', b'ant')
+        self.assertRaises(self.failureException, self.assertLessEqual, b'bug', b'ant')
+
+    def testAssertMultiLineEqual(self):
+        sample_text = """\
+http://www.python.org/doc/2.3/lib/module-unittest.html
+test case
+    A test case is the smallest unit of testing. [...]
+"""
+        revised_sample_text = """\
+http://www.python.org/doc/2.4.1/lib/module-unittest.html
+test case
+    A test case is the smallest unit of testing. [...] You may provide your
+    own implementation that does not subclass from TestCase, of course.
+"""
+        sample_text_error = """\
+- http://www.python.org/doc/2.3/lib/module-unittest.html
+?                             ^
++ http://www.python.org/doc/2.4.1/lib/module-unittest.html
+?                             ^^^
+  test case
+-     A test case is the smallest unit of testing. [...]
++     A test case is the smallest unit of testing. [...] You may provide your
+?                                                       +++++++++++++++++++++
++     own implementation that does not subclass from TestCase, of course.
+"""
+        self.maxDiff = None
+        try:
+            self.assertMultiLineEqual(sample_text, revised_sample_text)
+        except self.failureException as e:
+            # need to remove the first line of the error message
+            error = str(e).split('\n', 1)[1]
+
+            # no fair testing ourself with ourself, and assertEqual is used for strings
+            # so can't use assertEqual either. Just use assertTrue.
+            self.assertTrue(sample_text_error == error)
+
+    def testAsertEqualSingleLine(self):
+        sample_text = "laden swallows fly slowly"
+        revised_sample_text = "unladen swallows fly quickly"
+        sample_text_error = """\
+- laden swallows fly slowly
+?                    ^^^^
++ unladen swallows fly quickly
+? ++                   ^^^^^
+"""
+        try:
+            self.assertEqual(sample_text, revised_sample_text)
+        except self.failureException as e:
+            error = str(e).split('\n', 1)[1]
+            self.assertTrue(sample_text_error == error)
+
+    def testAssertIsNone(self):
+        self.assertIsNone(None)
+        self.assertRaises(self.failureException, self.assertIsNone, False)
+        self.assertIsNotNone('DjZoPloGears on Rails')
+        self.assertRaises(self.failureException, self.assertIsNotNone, None)
+
+    def testAssertRegex(self):
+        self.assertRegex('asdfabasdf', r'ab+')
+        self.assertRaises(self.failureException, self.assertRegex,
+                          'saaas', r'aaaa')
+
+    def testAssertRaisesRegex(self):
+        class ExceptionMock(Exception):
+            pass
+
+        def Stub():
+            raise ExceptionMock('We expect')
+
+        self.assertRaisesRegex(ExceptionMock, re.compile('expect$'), Stub)
+        self.assertRaisesRegex(ExceptionMock, 'expect$', Stub)
+
+    def testAssertNotRaisesRegex(self):
+        self.assertRaisesRegex(
+                self.failureException, '^Exception not raised by <lambda>$',
+                self.assertRaisesRegex, Exception, re.compile('x'),
+                lambda: None)
+        self.assertRaisesRegex(
+                self.failureException, '^Exception not raised by <lambda>$',
+                self.assertRaisesRegex, Exception, 'x',
+                lambda: None)
+
+    def testAssertRaisesRegexMismatch(self):
+        def Stub():
+            raise Exception('Unexpected')
+
+        self.assertRaisesRegex(
+                self.failureException,
+                r'"\^Expected\$" does not match "Unexpected"',
+                self.assertRaisesRegex, Exception, '^Expected$',
+                Stub)
+        self.assertRaisesRegex(
+                self.failureException,
+                r'"\^Expected\$" does not match "Unexpected"',
+                self.assertRaisesRegex, Exception,
+                re.compile('^Expected$'), Stub)
+
+    def testAssertRaisesExcValue(self):
+        class ExceptionMock(Exception):
+            pass
+
+        def Stub(foo):
+            raise ExceptionMock(foo)
+        v = "particular value"
+
+        ctx = self.assertRaises(ExceptionMock)
+        with ctx:
+            Stub(v)
+        e = ctx.exception
+        self.assertIsInstance(e, ExceptionMock)
+        self.assertEqual(e.args[0], v)
+
+    def testAssertWarnsCallable(self):
+        def _runtime_warn():
+            warnings.warn("foo", RuntimeWarning)
+        # Success when the right warning is triggered, even several times
+        self.assertWarns(RuntimeWarning, _runtime_warn)
+        self.assertWarns(RuntimeWarning, _runtime_warn)
+        # A tuple of warning classes is accepted
+        self.assertWarns((DeprecationWarning, RuntimeWarning), _runtime_warn)
+        # *args and **kwargs also work
+        self.assertWarns(RuntimeWarning,
+                         warnings.warn, "foo", category=RuntimeWarning)
+        # Failure when no warning is triggered
+        with self.assertRaises(self.failureException):
+            self.assertWarns(RuntimeWarning, lambda: 0)
+        # Failure when another warning is triggered
+        with warnings.catch_warnings():
+            # Force default filter (in case tests are run with -We)
+            warnings.simplefilter("default", RuntimeWarning)
+            with self.assertRaises(self.failureException):
+                self.assertWarns(DeprecationWarning, _runtime_warn)
+        # Filters for other warnings are not modified
+        with warnings.catch_warnings():
+            warnings.simplefilter("error", RuntimeWarning)
+            with self.assertRaises(RuntimeWarning):
+                self.assertWarns(DeprecationWarning, _runtime_warn)
+
+    def testAssertWarnsContext(self):
+        # Believe it or not, it is preferrable to duplicate all tests above,
+        # to make sure the __warningregistry__ $@ is circumvented correctly.
+        def _runtime_warn():
+            warnings.warn("foo", RuntimeWarning)
+        _runtime_warn_lineno = inspect.getsourcelines(_runtime_warn)[1]
+        with self.assertWarns(RuntimeWarning) as cm:
+            _runtime_warn()
+        # A tuple of warning classes is accepted
+        with self.assertWarns((DeprecationWarning, RuntimeWarning)) as cm:
+            _runtime_warn()
+        # The context manager exposes various useful attributes
+        self.assertIsInstance(cm.warning, RuntimeWarning)
+        self.assertEqual(cm.warning.args[0], "foo")
+        self.assertIn("test_case.py", cm.filename)
+        self.assertEqual(cm.lineno, _runtime_warn_lineno + 1)
+        # Same with several warnings
+        with self.assertWarns(RuntimeWarning):
+            _runtime_warn()
+            _runtime_warn()
+        with self.assertWarns(RuntimeWarning):
+            warnings.warn("foo", category=RuntimeWarning)
+        # Failure when no warning is triggered
+        with self.assertRaises(self.failureException):
+            with self.assertWarns(RuntimeWarning):
+                pass
+        # Failure when another warning is triggered
+        with warnings.catch_warnings():
+            # Force default filter (in case tests are run with -We)
+            warnings.simplefilter("default", RuntimeWarning)
+            with self.assertRaises(self.failureException):
+                with self.assertWarns(DeprecationWarning):
+                    _runtime_warn()
+        # Filters for other warnings are not modified
+        with warnings.catch_warnings():
+            warnings.simplefilter("error", RuntimeWarning)
+            with self.assertRaises(RuntimeWarning):
+                with self.assertWarns(DeprecationWarning):
+                    _runtime_warn()
+
+    def testAssertWarnsRegexCallable(self):
+        def _runtime_warn(msg):
+            warnings.warn(msg, RuntimeWarning)
+        self.assertWarnsRegex(RuntimeWarning, "o+",
+                              _runtime_warn, "foox")
+        # Failure when no warning is triggered
+        with self.assertRaises(self.failureException):
+            self.assertWarnsRegex(RuntimeWarning, "o+",
+                                  lambda: 0)
+        # Failure when another warning is triggered
+        with warnings.catch_warnings():
+            # Force default filter (in case tests are run with -We)
+            warnings.simplefilter("default", RuntimeWarning)
+            with self.assertRaises(self.failureException):
+                self.assertWarnsRegex(DeprecationWarning, "o+",
+                                      _runtime_warn, "foox")
+        # Failure when message doesn't match
+        with self.assertRaises(self.failureException):
+            self.assertWarnsRegex(RuntimeWarning, "o+",
+                                  _runtime_warn, "barz")
+        # A little trickier: we ask RuntimeWarnings to be raised, and then
+        # check for some of them.  It is implementation-defined whether
+        # non-matching RuntimeWarnings are simply re-raised, or produce a
+        # failureException.
+        with warnings.catch_warnings():
+            warnings.simplefilter("error", RuntimeWarning)
+            with self.assertRaises((RuntimeWarning, self.failureException)):
+                self.assertWarnsRegex(RuntimeWarning, "o+",
+                                      _runtime_warn, "barz")
+
+    def testAssertWarnsRegexContext(self):
+        # Same as above, but with assertWarnsRegex as a context manager
+        def _runtime_warn(msg):
+            warnings.warn(msg, RuntimeWarning)
+        _runtime_warn_lineno = inspect.getsourcelines(_runtime_warn)[1]
+        with self.assertWarnsRegex(RuntimeWarning, "o+") as cm:
+            _runtime_warn("foox")
+        self.assertIsInstance(cm.warning, RuntimeWarning)
+        self.assertEqual(cm.warning.args[0], "foox")
+        self.assertIn("test_case.py", cm.filename)
+        self.assertEqual(cm.lineno, _runtime_warn_lineno + 1)
+        # Failure when no warning is triggered
+        with self.assertRaises(self.failureException):
+            with self.assertWarnsRegex(RuntimeWarning, "o+"):
+                pass
+        # Failure when another warning is triggered
+        with warnings.catch_warnings():
+            # Force default filter (in case tests are run with -We)
+            warnings.simplefilter("default", RuntimeWarning)
+            with self.assertRaises(self.failureException):
+                with self.assertWarnsRegex(DeprecationWarning, "o+"):
+                    _runtime_warn("foox")
+        # Failure when message doesn't match
+        with self.assertRaises(self.failureException):
+            with self.assertWarnsRegex(RuntimeWarning, "o+"):
+                _runtime_warn("barz")
+        # A little trickier: we ask RuntimeWarnings to be raised, and then
+        # check for some of them.  It is implementation-defined whether
+        # non-matching RuntimeWarnings are simply re-raised, or produce a
+        # failureException.
+        with warnings.catch_warnings():
+            warnings.simplefilter("error", RuntimeWarning)
+            with self.assertRaises((RuntimeWarning, self.failureException)):
+                with self.assertWarnsRegex(RuntimeWarning, "o+"):
+                    _runtime_warn("barz")
+
+    def testDeprecatedMethodNames(self):
+        """Test that the deprecated methods raise a DeprecationWarning.
+
+        The fail* methods will be removed in 3.3. The assert* methods will
+        have to stay around for a few more versions.  See #9424.
+        """
+        old = (
+            (self.assertNotEquals, (3, 5)),
+            (self.assertEquals, (3, 3)),
+            (self.assertAlmostEquals, (2.0, 2.0)),
+            (self.assertNotAlmostEquals, (3.0, 5.0)),
+            (self.assert_, (True,)),
+            (self.assertRaisesRegexp, (KeyError, 'foo', lambda: {}['foo'])),
+            (self.assertRegexpMatches, ('bar', 'bar')),
+        )
+        for meth, args in old:
+            with self.assertWarns(DeprecationWarning):
+                meth(*args)
+
+    def testDeepcopy(self):
+        # Issue: 5660
+        class TestableTest(unittest.TestCase):
+            def testNothing(self):
+                pass
+
+        test = TestableTest('testNothing')
+
+        # This shouldn't blow up
+        deepcopy(test)
+
+    def testPickle(self):
+        # Issue 10326
+
+        # Can't use TestCase classes defined in Test class as
+        # pickle does not work with inner classes
+        test = unittest.TestCase('run')
+        for protocol in range(pickle.HIGHEST_PROTOCOL + 1):
+
+            # blew up prior to fix
+            pickled_test = pickle.dumps(test, protocol=protocol)
+            unpickled_test = pickle.loads(pickled_test)
+            self.assertEqual(test, unpickled_test)
+
+            # exercise the TestCase instance in a way that will invoke
+            # the type equality lookup mechanism
+            unpickled_test.assertEqual(set(), set())
+
+    def testKeyboardInterrupt(self):
+        def _raise(self=None):
+            raise KeyboardInterrupt
+        def nothing(self):
+            pass
+
+        class Test1(unittest.TestCase):
+            test_something = _raise
+
+        class Test2(unittest.TestCase):
+            setUp = _raise
+            test_something = nothing
+
+        class Test3(unittest.TestCase):
+            test_something = nothing
+            tearDown = _raise
+
+        class Test4(unittest.TestCase):
+            def test_something(self):
+                self.addCleanup(_raise)
+
+        for klass in (Test1, Test2, Test3, Test4):
+            with self.assertRaises(KeyboardInterrupt):
+                klass('test_something').run()
+
+    def testSkippingEverywhere(self):
+        def _skip(self=None):
+            raise unittest.SkipTest('some reason')
+        def nothing(self):
+            pass
+
+        class Test1(unittest.TestCase):
+            test_something = _skip
+
+        class Test2(unittest.TestCase):
+            setUp = _skip
+            test_something = nothing
+
+        class Test3(unittest.TestCase):
+            test_something = nothing
+            tearDown = _skip
+
+        class Test4(unittest.TestCase):
+            def test_something(self):
+                self.addCleanup(_skip)
+
+        for klass in (Test1, Test2, Test3, Test4):
+            result = unittest.TestResult()
+            klass('test_something').run(result)
+            self.assertEqual(len(result.skipped), 1)
+            self.assertEqual(result.testsRun, 1)
+
+    def testSystemExit(self):
+        def _raise(self=None):
+            raise SystemExit
+        def nothing(self):
+            pass
+
+        class Test1(unittest.TestCase):
+            test_something = _raise
+
+        class Test2(unittest.TestCase):
+            setUp = _raise
+            test_something = nothing
+
+        class Test3(unittest.TestCase):
+            test_something = nothing
+            tearDown = _raise
+
+        class Test4(unittest.TestCase):
+            def test_something(self):
+                self.addCleanup(_raise)
+
+        for klass in (Test1, Test2, Test3, Test4):
+            result = unittest.TestResult()
+            klass('test_something').run(result)
+            self.assertEqual(len(result.errors), 1)
+            self.assertEqual(result.testsRun, 1)
diff -u -x '*.pyc' --recursive --new-file cpython/Lib/unittest/test/test_discovery.py unittest2/test/test_discovery.py
--- cpython/Lib/unittest/test/test_discovery.py	2011-03-24 02:43:51.000000000 -0400
+++ unittest2/test/test_discovery.py	2011-03-25 21:38:23.000000000 -0400
@@ -2,7 +2,7 @@
 import re
 import sys
 
-import unittest
+import unittest2 as unittest
 
 
 class TestableTestProgram(unittest.TestProgram):
@@ -386,7 +386,7 @@
             self.assertEqual(start_dir, expectedPath)
             return tests
         loader._find_tests = _find_tests
-        suite = loader.discover('unittest.test')
+        suite = loader.discover('unittest2.test')
         self.assertTrue(self.wasRun)
         self.assertEqual(suite._tests, tests)
 
diff -u -x '*.pyc' --recursive --new-file cpython/Lib/unittest/test/test_functiontestcase.py unittest2/test/test_functiontestcase.py
--- cpython/Lib/unittest/test/test_functiontestcase.py	2011-03-24 02:43:51.000000000 -0400
+++ unittest2/test/test_functiontestcase.py	2011-03-25 21:38:23.000000000 -0400
@@ -1,4 +1,4 @@
-import unittest
+import unittest2 as unittest
 
 from .support import LoggingResult
 
diff -u -x '*.pyc' --recursive --new-file cpython/Lib/unittest/test/test_loader.py unittest2/test/test_loader.py
--- cpython/Lib/unittest/test/test_loader.py	2011-03-24 02:43:51.000000000 -0400
+++ unittest2/test/test_loader.py	2011-03-25 21:38:23.000000000 -0400
@@ -2,7 +2,7 @@
 import types
 
 
-import unittest
+import unittest2 as unittest
 
 
 class Test_TestLoader(unittest.TestCase):
@@ -239,7 +239,7 @@
         try:
             loader.loadTestsFromName('sdasfasfasdf')
         except ImportError as e:
-            self.assertEqual(str(e), "No module named 'sdasfasfasdf'")
+            self.assertEqual(str(e), "No module named sdasfasfasdf")
         else:
             self.fail("TestLoader.loadTestsFromName failed to raise ImportError")
 
@@ -524,7 +524,7 @@
         # We're going to try to load this module as a side-effect, so it
         # better not be loaded before we try.
         #
-        module_name = 'unittest.test.dummy'
+        module_name = 'unittest2.test.dummy'
         sys.modules.pop(module_name, None)
 
         loader = unittest.TestLoader()
@@ -619,7 +619,7 @@
         try:
             loader.loadTestsFromNames(['sdasfasfasdf'])
         except ImportError as e:
-            self.assertEqual(str(e), "No module named 'sdasfasfasdf'")
+            self.assertEqual(str(e), "No module named sdasfasfasdf")
         else:
             self.fail("TestLoader.loadTestsFromNames failed to raise ImportError")
 
@@ -907,7 +907,7 @@
         # We're going to try to load this module as a side-effect, so it
         # better not be loaded before we try.
         #
-        module_name = 'unittest.test.dummy'
+        module_name = 'unittest2.test.dummy'
         sys.modules.pop(module_name, None)
 
         loader = unittest.TestLoader()
@@ -1290,3 +1290,7 @@
     def test_suiteClass__default_value(self):
         loader = unittest.TestLoader()
         self.assertTrue(loader.suiteClass is unittest.TestSuite)
+
+    def testBaseClassInheritance(self):
+        import unittest as unittestorig
+        self.assertTrue(issubclass(unittest.TestLoader, unittestorig.TestLoader))
diff -u -x '*.pyc' --recursive --new-file cpython/Lib/unittest/test/test_program.py unittest2/test/test_program.py
--- cpython/Lib/unittest/test/test_program.py	2011-03-24 02:43:51.000000000 -0400
+++ unittest2/test/test_program.py	2011-03-25 21:38:23.000000000 -0400
@@ -2,7 +2,7 @@
 
 import os
 import sys
-import unittest
+import unittest2 as unittest
 
 
 class Test_TestProgram(unittest.TestCase):
@@ -19,7 +19,7 @@
             self.assertEqual(start_dir, expectedPath)
             return tests
         loader._find_tests = _find_tests
-        suite = loader.discover('unittest.test')
+        suite = loader.discover('unittest2.test')
         self.assertTrue(self.wasRun)
         self.assertEqual(suite._tests, tests)
 
@@ -91,6 +91,9 @@
             testRunner=unittest.TextTestRunner(stream=io.StringIO()),
             testLoader=self.FooBarLoader())
 
+    def testBaseClassInheritance(self):
+        import unittest as unittestorig
+        self.assertTrue(issubclass(unittest.TestProgram, unittestorig.TestProgram))
 
 class InitialisableProgram(unittest.TestProgram):
     exit = False
@@ -255,7 +258,7 @@
         self.assertIs(program.result, RESULT)
 
     def testCatchBreakInstallsHandler(self):
-        module = sys.modules['unittest.main']
+        module = sys.modules['unittest2.main']
         original = module.installHandler
         def restore():
             module.installHandler = original
@@ -353,6 +356,5 @@
         # for invalid filenames should we raise a useful error rather than
         # leaving the current error message (import of filename fails) in place?
 
-
 if __name__ == '__main__':
     unittest.main()
diff -u -x '*.pyc' --recursive --new-file cpython/Lib/unittest/test/test_result.py unittest2/test/test_result.py
--- cpython/Lib/unittest/test/test_result.py	2011-03-24 02:43:51.000000000 -0400
+++ unittest2/test/test_result.py	2011-03-25 21:38:23.000000000 -0400
@@ -2,11 +2,10 @@
 import sys
 import textwrap
 
-from test import support
-
 import traceback
-import unittest
+import unittest2 as unittest
 
+from .support import check_warnings
 
 class Test_TestResult(unittest.TestCase):
     # Note: there are not separate tests for TestResult.wasSuccessful(),
@@ -294,6 +293,10 @@
             self.assertTrue(result.failfast)
         result = runner.run(test)
 
+    def testBaseClassInheritance(self):
+        import unittest as unittestorig
+        self.assertTrue(issubclass(unittest.TestResult, unittestorig.TestResult))
+
 
 classDict = dict(unittest.TestResult.__dict__)
 for m in ('addSkip', 'addExpectedFailure', 'addUnexpectedSuccess',
@@ -313,7 +316,7 @@
 class Test_OldTestResult(unittest.TestCase):
 
     def assertOldResultWarning(self, test, failures):
-        with support.check_warnings(("TestResult has no add.+ method,",
+        with check_warnings(("TestResult has no add.+ method,",
                                      RuntimeWarning)):
             result = OldResult()
             test.run(result)
diff -u -x '*.pyc' --recursive --new-file cpython/Lib/unittest/test/test_runner.py unittest2/test/test_runner.py
--- cpython/Lib/unittest/test/test_runner.py	2011-03-24 02:43:51.000000000 -0400
+++ unittest2/test/test_runner.py	2011-03-25 21:38:23.000000000 -0400
@@ -4,7 +4,7 @@
 import pickle
 import subprocess
 
-import unittest
+import unittest2 as unittest
 
 from .support import LoggingResult, ResultWithNoStartTestRunStopTestRun
 
@@ -222,6 +222,8 @@
         expected = ['startTestRun', 'stopTestRun']
         self.assertEqual(events, expected)
 
+    @unittest.skipIf(sys.version_info[:2] < (3, 2), 
+                      "io.StringIO() not pickleable until Python 3.2")
     def test_pickle_unpickle(self):
         # Issue #7197: a TextTestRunner should be (un)pickleable. This is
         # required by test_multiprocessing under Windows (in verbose mode).
diff -u -x '*.pyc' --recursive --new-file cpython/Lib/unittest/test/test_setups.py unittest2/test/test_setups.py
--- cpython/Lib/unittest/test/test_setups.py	2011-03-24 02:43:51.000000000 -0400
+++ unittest2/test/test_setups.py	2011-03-25 21:38:23.000000000 -0400
@@ -1,7 +1,7 @@
 import io
 import sys
 
-import unittest
+import unittest2 as unittest
 
 
 def resultFactory(*_):
diff -u -x '*.pyc' --recursive --new-file cpython/Lib/unittest/test/test_skipping.py unittest2/test/test_skipping.py
--- cpython/Lib/unittest/test/test_skipping.py	2011-03-24 02:43:51.000000000 -0400
+++ unittest2/test/test_skipping.py	2011-03-25 21:38:23.000000000 -0400
@@ -1,4 +1,4 @@
-import unittest
+import unittest2 as unittest
 
 from .support import LoggingResult
 
diff -u -x '*.pyc' --recursive --new-file cpython/Lib/unittest/test/test_suite.py unittest2/test/test_suite.py
--- cpython/Lib/unittest/test/test_suite.py	2011-03-24 02:43:51.000000000 -0400
+++ unittest2/test/test_suite.py	2011-03-25 21:38:23.000000000 -0400
@@ -1,4 +1,4 @@
-import unittest
+import unittest2 as unittest
 
 import sys
 from .support import LoggingResult, TestEquality
@@ -362,6 +362,10 @@
         # reusing results should be permitted even if abominable
         self.assertFalse(result._testRunEntered)
 
+    def testBaseClassInheritance(self):
+        import unittest as unittestorig
+        self.assertTrue(issubclass(unittest.TestSuite, unittestorig.TestSuite))
+
 
 
 if __name__ == '__main__':
diff -u -x '*.pyc' --recursive --new-file cpython/Lib/unittest/test/_test_warnings.py unittest2/test/_test_warnings.py
--- cpython/Lib/unittest/test/_test_warnings.py	2011-03-24 02:43:51.000000000 -0400
+++ unittest2/test/_test_warnings.py	2011-03-25 21:38:23.000000000 -0400
@@ -12,7 +12,7 @@
 
 import io
 import sys
-import unittest
+import unittest2 as unittest
 import warnings
 
 def warnfun():
diff -u -x '*.pyc' --recursive --new-file cpython/Lib/unittest/util.py unittest2/util.py
--- cpython/Lib/unittest/util.py	2011-03-24 02:43:51.000000000 -0400
+++ unittest2/util.py	2011-03-25 21:38:23.000000000 -0400
@@ -1,6 +1,7 @@
 """Various utility functions."""
 
-from collections import namedtuple, OrderedDict
+from collections import namedtuple
+from .compatibility import OrderedDict
 
 __unittest = True
 
